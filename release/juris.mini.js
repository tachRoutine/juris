(function () { "use strict"; const jurisLinesOfCode = 3377, jurisVersion = "0.87.2", jurisMinifiedSize = "66.96 kB", isValidPath = e => "string" == typeof e && e.trim().length > 0 && !e.includes(".."), getPathParts = e => e.split(".").filter(Boolean), deepEquals = (e, t) => { if (e === t) return !0; if (null == e || null == t || typeof e != typeof t) return !1; if ("object" == typeof e) { if (Array.isArray(e) !== Array.isArray(t)) return !1; const n = Object.keys(e), s = Object.keys(t); return n.length === s.length && n.every((n => s.includes(n) && deepEquals(e[n], t[n]))) } return !1 }, createLogger = () => { const e = [], t = (t, n, s) => { const r = { formatted: `${s ? `[${s}] ` : ""}${t}${n ? ` ${JSON.stringify(n)}` : ""}`, message: t, context: n, category: s, timestamp: Date.now() }; return setTimeout((() => e.forEach((e => e(r)))), 0), r }; return { log: { l: t, w: t, e: t, i: t, d: t }, sub: t => e.push(t), unsub: t => e.splice(e.indexOf(t), 1) } }, { log: log, logSub: logSub, logUnsub: logUnsub } = createLogger(), createPromisify = () => { const e = new Set; let t = !1; const n = new Set, s = () => { 0 === e.size && n.size > 0 && n.forEach((e => e())) }; return { promisify: n => { const r = n?.then ? n : Promise.resolve(n); return t && r !== n && (e.add(r), r.finally((() => { e.delete(r), setTimeout(s, 0) }))), r }, startTracking: () => { t = !0, e.clear() }, stopTracking: () => { t = !1, n.clear() }, onAllComplete: t => (n.add(t), 0 === e.size && setTimeout(t, 0), () => n.delete(t)) } }, { promisify: promisify, startTracking: startTracking, stopTracking: stopTracking, onAllComplete: onAllComplete } = createPromisify(); class StateManager { constructor(e = {}, t = []) { console.info(log.i("StateManager initialized", { initialStateKeys: Object.keys(e), middlewareCount: t.length }, "framework")), this.state = { ...e }, this.middleware = [...t], this.subscribers = new Map, this.externalSubscribers = new Map, this.currentTracking = null, this.isUpdating = !1, this.initialState = JSON.parse(JSON.stringify(e)), this.maxUpdateDepth = 50, this.updateDepth = 0, this.currentlyUpdating = new Set, this.isBatching = !1, this.batchQueue = [], this.batchedPaths = new Set } reset() { console.info(log.i("State reset to initial state", {}, "framework")), this.isBatching && (this.batchQueue = [], this.batchedPaths.clear(), this.isBatching = !1), this.state = JSON.parse(JSON.stringify(this.initialState)) } getState(e, t = null, n = !0) { if (!isValidPath(e)) return t; n && this.currentTracking?.add(e); const s = getPathParts(e); let r = this.state; for (const e of s) { if (void 0 === r?.[e]) return t; r = r[e] } return r } setState(e, t, n = {}) { console.debug(log.d("State change initiated", { path: e, hasValue: void 0 !== t }, "application")), isValidPath(e) && !this._hasCircularUpdate(e) && (this.isBatching ? this._queueBatchedUpdate(e, t, n) : this._setStateImmediate(e, t, n)) } executeBatch(e) { if (this.isBatching) return e(); this.beginBatch(); try { const t = e(); return t && "function" == typeof t.then ? t.then((e => (this.endBatch(), e))).catch((e => { throw this.endBatch(), e })) : (this.endBatch(), t) } catch (e) { throw this.endBatch(), e } } beginBatch() { console.debug(log.d("Manual batch started", {}, "framework")), this.isBatching = !0, this.batchQueue = [], this.batchedPaths.clear() } endBatch() { this.isBatching ? (console.debug(log.d("Manual batch ending", { queuedUpdates: this.batchQueue.length }, "framework")), this.isBatching = !1, 0 !== this.batchQueue.length && this._processBatchedUpdates()) : console.warn(log.w("endBatch() called without beginBatch()", {}, "framework")) } isBatchingActive() { return this.isBatching } getBatchQueueSize() { return this.batchQueue.length } clearBatch() { this.isBatching && (console.info(log.i("Clearing current batch", { clearedUpdates: this.batchQueue.length }, "framework")), this.batchQueue = [], this.batchedPaths.clear()) } _queueBatchedUpdate(e, t, n) { this.batchQueue = this.batchQueue.filter((t => t.path !== e)), this.batchQueue.push({ path: e, value: t, context: n, timestamp: Date.now() }), this.batchedPaths.add(e) } _processBatchedUpdates() { const e = [...this.batchQueue]; this.batchQueue = [], this.batchedPaths.clear(); const t = new Map; e.forEach((e => t.set(e.path, e))); const n = this.isUpdating; this.isUpdating = !0; const s = []; t.forEach((e => { const t = this.getState(e.path); let n = e.value; for (const s of this.middleware) try { const r = s({ path: e.path, oldValue: t, newValue: n, context: e.context, state: this.state }); void 0 !== r && (n = r) } catch (t) { console.error(log.e("Middleware error in batch", { path: e.path, error: t.message }, "application")) } if (deepEquals(t, n)) return; const r = getPathParts(e.path); let i = this.state; for (let e = 0; e < r.length - 1; e++) { const t = r[e]; null != i[t] && "object" == typeof i[t] || (i[t] = {}), i = i[t] } i[r[r.length - 1]] = n, s.push({ path: e.path, oldValue: t, newValue: n }) })), this.isUpdating = n; const r = new Set; s.forEach((({ path: e }) => { const t = getPathParts(e); for (let e = 1; e <= t.length; e++)r.add(t.slice(0, e).join(".")) })), r.forEach((e => { this.subscribers.has(e) && this._triggerPathSubscribers(e), this.externalSubscribers.has(e) && this.externalSubscribers.get(e).forEach((({ callback: t, hierarchical: n }) => { try { t(this.getState(e), null, e) } catch (e) { console.error(log.e("External subscriber error:", e), "application") } })) })) } _setStateImmediate(e, t, n = {}) { const s = this.getState(e); let r = t; for (const t of this.middleware) try { const i = t({ path: e, oldValue: s, newValue: r, context: n, state: this.state }); void 0 !== i && (r = i) } catch (n) { console.error(log.e("Middleware error", { path: e, error: n.message, middlewareName: t.name || "anonymous" }, "application")) } if (deepEquals(s, r)) return void console.debug(log.d("State unchanged, skipping update", { path: e }, "framework")); console.debug(log.d("State updated", { path: e, oldValue: typeof s, newValue: typeof r }, "application")); const i = getPathParts(e); let o = this.state; for (let e = 0; e < i.length - 1; e++) { const t = i[e]; null != o[t] && "object" == typeof o[t] || (o[t] = {}), o = o[t] } o[i[i.length - 1]] = r, this.isUpdating || (this.isUpdating = !0, this.currentlyUpdating || (this.currentlyUpdating = new Set), this.currentlyUpdating.add(e), this._notifySubscribers(e, r, s), this._notifyExternalSubscribers(e, r, s), this.currentlyUpdating.delete(e), this.isUpdating = !1) } subscribe(e, t, n = !0) { this.externalSubscribers.has(e) || this.externalSubscribers.set(e, new Set); const s = { callback: t, hierarchical: n }; return this.externalSubscribers.get(e).add(s), () => { const t = this.externalSubscribers.get(e); t && (t.delete(s), 0 === t.size && this.externalSubscribers.delete(e)) } } subscribeExact(e, t) { return this.subscribe(e, t, !1) } subscribeInternal(e, t) { return this.subscribers.has(e) || this.subscribers.set(e, new Set), this.subscribers.get(e).add(t), () => { const n = this.subscribers.get(e); n && (n.delete(t), 0 === n.size && this.subscribers.delete(e)) } } _notifySubscribers(e, t, n) { this._triggerPathSubscribers(e); const s = getPathParts(e); for (let e = s.length - 1; e > 0; e--)this._triggerPathSubscribers(s.slice(0, e).join(".")); const r = e ? e + "." : ""; new Set([...this.subscribers.keys(), ...this.externalSubscribers.keys()]).forEach((t => { t.startsWith(r) && t !== e && this._triggerPathSubscribers(t) })) } _notifyExternalSubscribers(e, t, n) { this.externalSubscribers.forEach(((s, r) => { s.forEach((({ callback: s, hierarchical: i }) => { if (i ? e === r || e.startsWith(r + ".") : e === r) try { s(t, n, e) } catch (e) { console.error(log.e("External subscriber error:", e), "application") } })) })) } _triggerPathSubscribers(e) { const t = this.subscribers.get(e); t && t.size > 0 && (console.debug(log.d("Triggering subscribers", { path: e, subscriberCount: t.size }, "framework")), new Set(t).forEach((e => { let t; try { t = this.currentTracking; const n = new Set; this.currentTracking = n, e(), this.currentTracking = t, n.forEach((t => { const n = this.subscribers.get(t); n && n.has(e) || this.subscribeInternal(t, e) })) } catch (e) { console.error(log.e("Subscriber error:", e), "application"), this.currentTracking = t } }))) } _hasCircularUpdate(e) { return this.currentlyUpdating || (this.currentlyUpdating = new Set), !!this.currentlyUpdating.has(e) && (console.warn(log.w("Circular dependency detected", { path: e }, "framework")), !0) } startTracking() { const e = new Set; return this.currentTracking = e, e } endTracking() { const e = this.currentTracking; return this.currentTracking = null, e || new Set } } class HeadlessManager { constructor(e) { console.info(log.i("HeadlessManager initialized", {}, "framework")), this.juris = e, this.components = new Map, this.instances = new Map, this.context = {}, this.initQueue = new Set, this.lifecycleHooks = new Map } register(e, t, n = {}) { console.info(log.i("Headless component registered", { name: e, hasOptions: Object.keys(n).length > 0 }, "framework")), this.components.set(e, { fn: t, options: n }), n.autoInit && this.initQueue.add(e) } initialize(e, t = {}) { console.debug(log.d("Initializing headless component", { name: e, propsKeys: Object.keys(t) }, "framework")); const n = this.components.get(e); if (!n) return console.error(log.e("Headless component not found", { name: e }, "framework")), null; try { const s = this.juris.createHeadlessContext(), r = n.fn(t, s); return r && "object" == typeof r ? (console.info(log.i("Headless component initialized", { name: e, hasAPI: !!r.api, hasHooks: !!r.hooks }, "framework")), this.instances.set(e, r), r.hooks && this.lifecycleHooks.set(e, r.hooks), r.api && (this.context[e] = r.api, this.juris.headlessAPIs || (this.juris.headlessAPIs = {}), this.juris.headlessAPIs[e] = r.api, this.juris._updateComponentContexts()), r.hooks?.onRegister?.(), r) : (console.error(log.e("Invalid headless component instance", { name: e }, "framework")), null) } catch (t) { return console.error(log.e("Headless component initialization failed", { name: e, error: t.message }, "framework")), null } } initializeQueued() { this.initQueue.forEach((e => { if (!this.instances.has(e)) { const t = this.components.get(e); this.initialize(e, t.options || {}) } })), this.initQueue.clear() } getInstance(e) { return this.instances.get(e) } getAPI(e) { return this.context[e] } getAllAPIs() { return { ...this.context } } reinitialize(e, t = {}) { const n = this.instances.get(e); if (n?.hooks?.onUnregister) try { n.hooks.onUnregister() } catch (t) { console.error(log.e(`Error in onUnregister for '${e}':`, t), "framework") } return this.context[e] && delete this.context[e], this.juris.headlessAPIs?.[e] && delete this.juris.headlessAPIs[e], this.instances.delete(e), this.lifecycleHooks.delete(e), this.initialize(e, t) } cleanup() { console.info(log.i("Cleaning up headless components", { instanceCount: this.instances.size }, "framework")), this.instances.forEach(((e, t) => { if (e.hooks?.onUnregister) try { e.hooks.onUnregister() } catch (e) { console.error(log.e(`Error in onUnregister for '${t}':`, e), "framework") } })), this.instances.clear(), this.context = {}, this.lifecycleHooks.clear(), this.juris.headlessAPIs && (this.juris.headlessAPIs = {}) } getStatus() { return { registered: Array.from(this.components.keys()), initialized: Array.from(this.instances.keys()), queued: Array.from(this.initQueue), apis: Object.keys(this.context) } } } class ComponentManager { constructor(e) { console.info(log.i("ComponentManager initialized", {}, "framework")), this.juris = e, this.components = new Map, this.instances = new WeakMap, this.componentCounters = new Map, this.componentStates = new WeakMap, this.asyncPlaceholders = new WeakMap, this.asyncPropsCache = new Map } register(e, t) { console.info(log.i("Component registered", { name: e }, "application")), this.components.set(e, t) } create(e, t = {}) { const n = this.components.get(e); if (!n) return console.error(log.e("Component not found", { name: e }, "application")), null; try { if (this._hasAsyncProps(t)) return console.debug(log.d("Component has async props", { name: e }, "framework")), this._createWithAsyncProps(e, n, t); const { componentId: s, componentStates: r } = this._setupComponent(e); console.debug(log.d("Component setup complete", { name: e, componentId: s, stateCount: r.size }, "framework")); const i = n(t, this._createComponentContext(s, r)); return i?.then ? this._handleAsyncComponent(promisify(i), e, t, r) : this._processComponentResult(i, e, t, r) } catch (t) { return console.error(log.e("Component creation failed", { name: e, error: t.message }, "application")), this._createErrorElement(t) } } _setupComponent(e) { this.componentCounters.has(e) || this.componentCounters.set(e, 0); const t = this.componentCounters.get(e) + 1; this.componentCounters.set(e, t); return { componentId: `${e}_${t}`, componentStates: new Set } } _createComponentContext(e, t) { const n = this.juris.createContext(); return n.newState = (n, s) => { const r = `__local.${e}.${n}`; return this.juris.stateManager.getState(r, Symbol("not-found")) === Symbol("not-found") && this.juris.stateManager.setState(r, s), t.add(r), [() => this.juris.stateManager.getState(r, s), e => this.juris.stateManager.setState(r, e)] }, n } _hasAsyncProps(e) { return Object.values(e).some((e => e?.then)) } _createWithAsyncProps(e, t, n) { console.debug(log.d("Creating component with async props", { name: e }, "framework")); const s = document.createElement("div"); s.id = e.toLowerCase().replace(/[^a-z0-9]/g, "-"); const r = this._createPlaceholder(`Loading ${e}...`, "juris-async-props-loading", s); return this.asyncPlaceholders.set(r, { name: e, props: n, type: "async-props" }), this._resolveAsyncProps(n).then((n => { try { const s = this._createSyncComponent(e, t, n); s && r.parentNode && r.parentNode.replaceChild(s, r), this.asyncPlaceholders.delete(r) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } async _resolveAsyncProps(e) { const t = this._generateCacheKey(e), n = this.asyncPropsCache.get(t); if (n && Date.now() - n.timestamp < 5e3) return n.props; const s = {}; for (const [t, n] of Object.entries(e)) if (n?.then) try { s[t] = await n } catch (e) { s[t] = { __asyncError: e.message } } else s[t] = n; return this.asyncPropsCache.set(t, { props: s, timestamp: Date.now() }), s } _generateCacheKey(e) { return JSON.stringify(e, ((e, t) => t?.then ? "[Promise]" : t)) } _createSyncComponent(e, t, n) { const { componentId: s, componentStates: r } = this._setupComponent(e), i = t(n, this._createComponentContext(s, r)); return i?.then ? this._handleAsyncComponent(promisify(i), e, n, r) : this._processComponentResult(i, e, n, r) } _handleAsyncComponent(e, t, n, s) { console.debug(log.d("Handling async component", { name: t }, "framework")); const r = document.createElement("div"); r.id = t.toLowerCase().replace(/[^a-z0-9]/g, "-"); const i = this._createPlaceholder(`Loading ${t}...`, "juris-async-loading", r); return this.asyncPlaceholders.set(i, { name: t, props: n, componentStates: s }), e.then((e => { console.debug(log.d("Async component resolved", { name: t }, "framework")); try { const r = this._processComponentResult(e, t, n, s); r && i.parentNode && i.parentNode.replaceChild(r, i), this.asyncPlaceholders.delete(i) } catch (e) { console.error(log.e("Async component failed", { name: t, error: e.message }, "application")), this._replaceWithError(i, e) } })).catch((e => this._replaceWithError(i, e))), i } _processComponentResult(e, t, n, s) { if (e && "object" == typeof e) { if (this._hasLifecycleHooks(e)) return this._createLifecycleComponent(e, t, n, s); if ("function" == typeof e.render && !this._hasLifecycleHooks(e)) { const n = e.render(); if (n?.then) return this._handleAsyncRender(promisify(n), t, s, e.indicator); const r = this.juris.domRenderer.render(n); return r && s.size > 0 && this.componentStates.set(r, s), r } const r = Object.keys(e); if (1 === r.length && "string" == typeof r[0] && r[0].length > 0) { const t = this.juris.domRenderer.render(e); return t && s.size > 0 && this.componentStates.set(t, s), t } } const r = this.juris.domRenderer.render(e); return r && s.size > 0 && this.componentStates.set(r, s), r } _hasLifecycleHooks(e) { return e.hooks && (e.hooks.onMount || e.hooks.onUpdate || e.hooks.onUnmount) || e.onMount || e.onUpdate || e.onUnmount } _handleAsyncRender(e, t, n, s = null) { const r = document.createElement("div"); r.id = t.toLowerCase().replace(/[^a-z0-9]/g, "-"); const i = s ? this.juris.domRenderer.render(s) : this._createPlaceholder(`Loading ${t}...`, "juris-async-loading", r); return e.then((e => { try { const t = this.juris.domRenderer.render(e); t && n.size > 0 && this.componentStates.set(t, n), i.parentNode && i.parentNode.replaceChild(t, i) } catch (e) { this._replaceWithError(i, e) } })).catch((e => this._replaceWithError(i, e))), i } _createLifecycleComponent(e, t, n, s) { const r = { name: t, props: n, hooks: e.hooks || {}, api: e.api || {}, render: e.render }, i = r.render(); if (i?.then) return this._handleAsyncLifecycleRender(promisify(i), r, s); const o = this.juris.domRenderer.render(i); return o && (this.instances.set(o, r), s?.size > 0 && this.componentStates.set(o, s), r.hooks.onMount && setTimeout((() => { try { const e = r.hooks.onMount(); e?.then && promisify(e).catch((e => console.error(log.e(`Async onMount error in ${t}:`, e), "application"))) } catch (e) { console.error(log.e(`onMount error in ${t}:`, e), "application") } }), 0)), o } _handleAsyncLifecycleRender(e, t, n) { const s = document.createElement("div"); s.id = t.name.toLowerCase().replace(/[^a-z0-9]/g, "-"); const r = this._createPlaceholder(`Loading ${t.name}...`, "juris-async-lifecycle", s); return e.then((e => { try { const s = this.juris.domRenderer.render(e); s && (this.instances.set(s, t), n?.size > 0 && this.componentStates.set(s, n), r.parentNode && r.parentNode.replaceChild(s, r), t.hooks.onMount && setTimeout((() => { try { const e = t.hooks.onMount(); e?.then && promisify(e).catch((e => console.error(log.e(`Async onMount error in ${t.name}:`, e), "application"))) } catch (e) { console.error(log.e(`onMount error in ${t.name}:`, e), "application") } }), 0)) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } updateInstance(e, t) { const n = this.instances.get(e); if (!n) return; const s = n.props; deepEquals(s, t) || (this._hasAsyncProps(t) ? this._resolveAsyncProps(t).then((t => { n.props = t, this._performUpdate(n, e, s, t) })).catch((e => console.error(log.e(`Error updating async props for ${n.name}:`, e), "application"))) : (n.props = t, this._performUpdate(n, e, s, t))) } _performUpdate(e, t, n, s) { if (e.hooks.onUpdate) try { const t = e.hooks.onUpdate(n, s); t?.then && promisify(t).catch((t => console.error(log.e(`Async onUpdate error in ${e.name}:`, t), "application"))) } catch (t) { console.error(log.e(`onUpdate error in ${e.name}:`, t), "application") } try { const n = e.render(), s = promisify(n); s !== n ? s.then((e => { this.juris.domRenderer.updateElementContent(t, e) })).catch((t => console.error(log.e(`Async re-render error in ${e.name}:`, t), "application"))) : this.juris.domRenderer.updateElementContent(t, n) } catch (t) { console.error(log.e(`Re-render error in ${e.name}:`, t), "application") } } cleanup(e) { const t = this.instances.get(e); if (t && console.debug(log.d("Cleaning up component", { name: t.name }, "framework")), t?.hooks?.onUnmount) try { const e = t.hooks.onUnmount(); e?.then && promisify(e).catch((e => console.error(log.e(`Async onUnmount error in ${t.name}:`, e), "application"))) } catch (e) { console.error(log.e(`onUnmount error in ${t.name}:`, e), "application") } const n = this.componentStates.get(e); n && (n.forEach((e => { const t = e.split("."); let n = this.juris.stateManager.state; for (let e = 0; e < t.length - 1; e++) { if (!n[t[e]]) return; n = n[t[e]] } delete n[t[t.length - 1]] })), this.componentStates.delete(e)), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e), this.instances.delete(e) } _createPlaceholder(e, t, n = null) { const s = this.juris.domRenderer._getPlaceholderConfig(n), r = document.createElement("div"); return r.className = s.className, r.textContent = s.text, s.style && (r.style.cssText = s.style), r } _createErrorElement(e) { const t = document.createElement("div"); return t.style.cssText = "color: red; border: 1px solid red; padding: 8px; background: #ffe6e6;", t.textContent = `Component Error: ${e.message}`, t } _replaceWithError(e, t) { const n = this._createErrorElement(t); e.parentNode && e.parentNode.replaceChild(n, e), this.asyncPlaceholders.delete(e) } clearAsyncPropsCache() { this.asyncPropsCache.clear() } getAsyncStats() { return { registeredComponents: this.components.size, cachedAsyncProps: this.asyncPropsCache.size } } } class DOMRenderer { constructor(e) { console.info(log.i("DOMRenderer initialized", { renderMode: "fine-grained" }, "framework")), this.juris = e, this.subscriptions = new WeakMap, this.eventMap = { ondoubleclick: "dblclick", onmousedown: "mousedown", onmouseup: "mouseup", onmouseover: "mouseover", onmouseout: "mouseout", onmousemove: "mousemove", onkeydown: "keydown", onkeyup: "keyup", onkeypress: "keypress", onfocus: "focus", onblur: "blur", onchange: "change", oninput: "input", onsubmit: "submit", onload: "load", onresize: "resize", onscroll: "scroll" }, this.BOOLEAN_ATTRS = new Set(["disabled", "checked", "selected", "readonly", "multiple", "autofocus", "autoplay", "controls", "hidden", "loop", "open", "required", "reversed", "itemScope"]), this.PRESERVED_ATTRIBUTES = new Set(["viewBox", "preserveAspectRatio", "textLength", "gradientUnits", "gradientTransform", "spreadMethod", "patternUnits", "patternContentUnits", "patternTransform", "clipPath", "crossOrigin", "xmlns", "xmlns:xlink", "xlink:href"]), this.SVG_ELEMENTS = new Set(["svg", "g", "defs", "desc", "metadata", "title", "circle", "ellipse", "line", "polygon", "polyline", "rect", "path", "text", "tspan", "textPath", "marker", "pattern", "clipPath", "mask", "image", "switch", "foreignObject", "linearGradient", "radialGradient", "stop", "animate", "animateMotion", "animateTransform", "set", "use", "symbol"]), this.KEY_PROPS = ["id", "className", "text"], this.SKIP_ATTRS = new Set(["children", "key"]), this.ATTRIBUTES_TO_KEEP = new Set(["id", "data-juris-key"]), this.elementCache = new Map, this.recyclePool = new Map, this.renderMode = "fine-grained", this.failureCount = 0, this.maxFailures = 3, this.asyncCache = new Map, this.asyncPlaceholders = new WeakMap, this.placeholderConfigs = new Map, this.defaultPlaceholder = { className: "juris-async-loading", style: "padding: 8px; background: #f0f0f0; border: 1px dashed #ccc; opacity: 0.7;", text: "Loading...", children: null }, this.tempArray = [], this.tempKeyParts = [], this.TOUCH_CONFIG = { moveThreshold: 10, timeThreshold: 300, touchAction: "manipulation", tapHighlight: "transparent", touchCallout: "none" }, this.RECYCLE_POOL_SIZE = 100 } setRenderMode(e) { ["fine-grained", "batch"].includes(e) ? (this.renderMode = e, console.info(log.i("Render mode changed", { mode: e }, "framework"))) : console.warn(log.w("Invalid render mode", { mode: e }, "application")) } getRenderMode() { return this.renderMode } isFineGrained() { return "fine-grained" === this.renderMode } isBatchMode() { return "batch" === this.renderMode } render(e, t = !1) { if (console.debug(log.d("Render started", { vnodeType: typeof e, isArray: Array.isArray(e), staticMode: t }, "framework")), !e || "object" != typeof e) return null; if (Array.isArray(e)) { const n = document.createDocumentFragment(); for (let s = 0; s < e.length; s++) { const r = this.render(e[s], t); r && n.appendChild(r) } return n } const n = Object.keys(e)[0], s = e[n] || {}; if (!t && this.juris.componentManager.components.has(n)) { const e = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = null; const t = this.juris.componentManager.create(n, s); return this.juris.stateManager.currentTracking = e, t } if ("string" != typeof n || 0 === n.length) return null; if (t) return this._createElementStatic(n, s); if ("fine-grained" === this.renderMode) return this._createElementFineGrained(n, s); try { const e = s.key || this._generateKey(n, s), t = this.elementCache.get(e); return t && this._canReuseElement(t, n, s) ? (this._updateElementProperties(t, s), t) : this._createElementOptimized(n, s, e) } catch (e) { return this.failureCount++, this.failureCount >= this.maxFailures && (this.renderMode = "fine-grained"), this._createElementFineGrained(n, s) } } _createElementStatic(e, t) { const n = this.SVG_ELEMENTS.has(e.toLowerCase()) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e); for (const e in t) { if (!t.hasOwnProperty(e)) continue; const s = t[e]; if ("children" === e) this._updateChildrenStatic(n, s); else if ("text" === e) n.textContent = s; else if ("style" === e && "object" == typeof s) Object.assign(n.style, s); else if (e.startsWith("on")) { const t = "onclick" === e ? "click" : e.slice(2).toLowerCase(); n.addEventListener(t, s) } else "key" !== e && this._setStaticAttributeFast(n, e, s) } return n } _setStaticAttributeFast(e, t, n) { this.PRESERVED_ATTRIBUTES.has(t) || t.includes("-") || t.includes(":") ? e.setAttribute(t, n) : "className" === t ? e.className = n : "htmlFor" === t ? e.setAttribute("for", n) : "tabIndex" === t ? e.tabIndex = n : t in e && "function" != typeof e[t] ? e[t] = n : e.setAttribute(t, n) } _updateChildrenStatic(e, t) { if ("ignore" === t) return; e.textContent = ""; const n = document.createDocumentFragment(); if (Array.isArray(t)) { let e = t, s = !1; t.length > 0 && t[0]?.config?.staticMode && (s = !0, e = t.slice(1)); for (let t = 0; t < e.length; t++) { const r = this.render(e[t], s); r && n.appendChild(r) } } else if (t) { const e = this.render(t, !1); e && n.appendChild(e) } n.hasChildNodes() && e.appendChild(n) } _createElementFineGrained(e, t) { console.debug(log.d("Creating element (fine-grained)", { tagName: e, propsCount: Object.keys(t).length }, "framework")); const n = this.SVG_ELEMENTS.has(e.toLowerCase()) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e); this.tempArray.length = 0; const s = this.tempArray, r = []; for (const e in t) { if (!t.hasOwnProperty(e)) continue; const i = t[e]; "children" === e ? this._handleChildren(n, i, s) : "text" === e ? this._handleText(n, i, s) : "style" === e ? this._handleStyle(n, i, s) : e.startsWith("on") ? this._handleEvent(n, e, i, r) : "function" == typeof i ? this._handleReactiveAttribute(n, e, i, s) : this._isPromiseLike(i) ? this._handleAsyncProp(n, e, i, s) : "key" !== e && this._setStaticAttribute(n, e, i) } return (s.length > 0 || r.length > 0) && this.subscriptions.set(n, { subscriptions: [...s], eventListeners: r }), n } _handleChildren(e, t, n) { "fine-grained" === this.renderMode ? this._handleChildrenFineGrained(e, t, n) : this._handleChildrenOptimized(e, t, n) } _handleChildrenFineGrained(e, t, n) { if (Array.isArray(t) && t.length > 0 && t[0]?.config?.staticMode) return this._updateChildrenStatic(e, t); "function" == typeof t ? this._handleReactiveChildren(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncChildrenDirect(e, t) : this._updateChildren(e, t) } _handleChildrenOptimized(e, t, n) { if (Array.isArray(t) && t.length > 0 && t[0]?.config?.staticMode) return this._updateChildrenStatic(e, t); if ("function" == typeof t) { let s = null, r = [], i = !0; const o = () => { try { const n = t(e); if (this._isPromiseLike(n)) promisify(n).then((t => { if ("ignore" !== t && !this._childrenEqual(s, t)) if (i) try { r = this._reconcileChildren(e, r, t), s = t } catch (n) { console.warn(log.w("Reconciliation failed, falling back to safe rendering:", n.message), "framework"), i = !1, this._updateChildren(e, t), s = t } else this._updateChildren(e, t), s = t })).catch((e => { console.error(log.e("Error in async children function:", e), "framework"), i = !1 })); else if ("ignore" !== n && !this._childrenEqual(s, n)) if (i) try { r = this._reconcileChildren(e, r, n), s = n } catch (t) { console.warn(log.w("Reconciliation failed, falling back to safe rendering:", t.message), "framework"), i = !1, this._updateChildren(e, n), s = n } else this._updateChildren(e, n), s = n } catch (t) { console.error(log.e("Error in children function:", t), "application"), i = !1; try { this._updateChildren(e, []) } catch (e) { console.error(log.e("Even safe fallback failed:", e), "application") } } }; this._createReactiveUpdate(e, o, n); try { const n = t(); this._isPromiseLike(n) ? promisify(n).then((t => { r = this._reconcileChildren(e, [], t), s = t })).catch((t => { console.warn(log.w("Initial async children failed, using safe method:", t.message), "framework"), i = !1, this._updateChildren(e, []) })) : (r = this._reconcileChildren(e, [], n), s = n) } catch (n) { console.warn(log.w("Initial reconciliation failed, using safe method:", n.message), "framework"), i = !1; const r = t(); this._updateChildren(e, r), s = r } } else if (this._isPromiseLike(t)) this._handleAsyncChildrenDirect(e, t); else try { this._reconcileChildren(e, [], t) } catch (n) { console.warn(log.w("Static reconciliation failed, using safe method:", n.message), "framework"), this._updateChildren(e, t) } } _handleAsyncProp(e, t, n, s) { "text" === t ? this._handleAsyncTextDirect(e, n) : "children" === t ? this._handleAsyncChildrenDirect(e, n) : "style" === t ? this._handleAsyncStyleDirect(e, n) : "innerHTML" === t ? this._handleAsyncInnerHTMLDirect(e, n) : (this._setPlaceholder(e, t), promisify(n).then((n => { const s = this._getPlaceholderConfig(e); e.classList.remove(s.className), this._setStaticAttribute(e, t, n) })).catch((n => { console.error(log.e(`Async prop '${t}' failed:`, n), "application"), this._setErrorState(e, t, n.message) }))) } _handleAsyncInnerHTMLDirect(e, t) { const n = this._getPlaceholderConfig(e); e.innerHTML = `<span class="${n.className}">${n.text}</span>`, promisify(t).then((t => { e.innerHTML = t })).catch((t => { console.error(log.e("Async innerHTML failed:", t), "application"), e.innerHTML = `<span class="juris-async-error">Error: ${t.message}</span>` })) } _hasAsyncProps(e) { for (const t in e) if (e.hasOwnProperty(t) && !t.startsWith("on") && this._isPromiseLike(e[t])) return !0; return !1 } _isPromiseLike(e) { return e?.then } _getPlaceholderConfig(e) { if (e?.id && this.placeholderConfigs.has(e.id)) return this.placeholderConfigs.get(e.id); let t = e?.parentElement; for (; t;) { if (t.id && this.placeholderConfigs.has(t.id)) return this.placeholderConfigs.get(t.id); t = t.parentElement } return this.defaultPlaceholder } _setPlaceholder(e, t) { const n = this._getPlaceholderConfig(e); ({ text: () => { e.textContent = n.text, e.className = n.className, n.style && (e.style.cssText = n.style) }, children: () => { if (n.children) { const t = this.render(n.children); if (t) return void e.appendChild(t) } const t = document.createElement("span"); t.textContent = n.text, t.className = n.className, n.style && (t.style.cssText = n.style), e.appendChild(t) }, className: () => e.classList.add(n.className), style: () => { n.style && (e.style.cssText = n.style), e.classList.add(n.className) } }[t] || (() => { e.setAttribute(t, "loading"), e.classList.add(n.className) }))() } _setErrorState(e, t, n) { e.classList.add("juris-async-error"), "text" === t ? e.textContent = `Error: ${n}` : "children" === t && (e.innerHTML = `<span class="juris-async-error">Error: ${n}</span>`) } _childrenEqual(e, t) { return e === t || Array.isArray(e) === Array.isArray(t) && ((!Array.isArray(e) || e.length === t.length) && (deepEquals && deepEquals(e, t))) } _reconcileChildren(e, t, n) { console.debug(log.d("Reconciling children", { parentTag: e.tagName, oldCount: t.length, newCount: Array.isArray(n) ? n.length : n ? 1 : 0 }, "framework")), Array.isArray(n) || (n = n ? [n] : []); const s = [], r = document.createDocumentFragment(), i = new Map; for (let e = 0; e < t.length; e++) { const n = t[e], s = n._jurisKey || `auto-${e}`; i.set(s, n) } const o = new Set; for (let t = 0; t < n.length; t++) { const a = n[t]; if (!a || "object" != typeof a) continue; const c = Object.keys(a)[0], l = a[c] || {}, h = l.key || this._generateKey(c, l), d = i.get(h); if (d && !o.has(d) && this._canReuseElement(d, c, l) && !this._wouldCreateCircularReference(e, d)) d.parentNode && d.parentNode.removeChild(d), this._updateElementProperties(d, l), s.push(d), r.appendChild(d), o.add(d), i.delete(h); else { const t = this.render(a); t && !this._wouldCreateCircularReference(e, t) && (t._jurisKey = h, s.push(t), r.appendChild(t)) } } i.forEach((e => { o.has(e) || this._recycleElement(e) })); try { e.textContent = "", r.hasChildNodes() && e.appendChild(r) } catch (t) { console.error(log.e("Error in reconcileChildren:", t), "framework"), e.textContent = ""; for (let t = 0; t < s.length; t++) { const n = s[t]; try { n && !this._wouldCreateCircularReference(e, n) && e.appendChild(n) } catch (t) { console.error(log.e("Reconciliation failed", { parentTag: e.tagName, error: t.message }, "framework")) } } } return s } _wouldCreateCircularReference(e, t) { if (!e || !t) return !1; if (e === t) return !0; try { let n = e.parentNode; for (; n;) { if (n === t) return !0; n = n.parentNode } if (t.contains && t.contains(e)) return !0; if (t.children) for (let n = 0; n < t.children.length; n++)if (this._wouldCreateCircularReference(e, t.children[n])) return !0 } catch (e) { return console.warn(log.w("Error checking circular reference, assuming unsafe:", e), "application"), !0 } return !1 } _recycleElement(e) { if (!e || !e.tagName) return; const t = e.tagName.toLowerCase(); e.parentNode && e.parentNode.removeChild(e), this.recyclePool.has(t) || this.recyclePool.set(t, []); const n = this.recyclePool.get(t); n.length < this.RECYCLE_POOL_SIZE && (this.cleanup(e), this._resetElement(e), n.push(e)) } _handleAsyncChildrenDirect(e, t) { const n = this._getPlaceholderConfig(e); let s; n.children ? s = this.render(n.children) : (s = document.createElement("div"), s.className = n.className, s.textContent = n.text, n.style && (s.style.cssText = n.style)), e.appendChild(s), this.asyncPlaceholders.set(e, { type: "children", placeholder: s }), promisify(t).then((t => { s.parentNode && e.removeChild(s), this._updateChildren(e, t), this.asyncPlaceholders.delete(e) })).catch((e => { console.error(log.e("Async children failed:", e), "application"), s.textContent = `Error loading content: ${e.message}`, s.className = "juris-async-error" })) } _handleReactiveChildren(e, t, n) { let s = null, r = !1; this._createReactiveUpdate(e, (() => { try { const n = t(e); this._isPromiseLike(n) ? promisify(n).then((t => { "ignore" === t || r && deepEquals(t, s) || (this._updateChildren(e, t), s = t, r = !0) })).catch((e => console.error(log.e("Error in async reactive children:", e), "application"))) : "ignore" === n || r && deepEquals(n, s) || (this._updateChildren(e, n), s = n, r = !0) } catch (e) { console.error(log.e("Error in reactive children function:", e), "application") } }), n) } _updateChildren(e, t) { if ("ignore" === t) return; const n = Array.from(e.children); for (let e = 0; e < n.length; e++)this.cleanup(n[e]); e.textContent = ""; const s = document.createDocumentFragment(); if (Array.isArray(t)) for (let e = 0; e < t.length; e++) { const n = this.render(t[e]); n && s.appendChild(n) } else if (t) { const e = this.render(t); e && s.appendChild(e) } s.hasChildNodes() && e.appendChild(s) } _handleText(e, t, n) { "function" == typeof t ? this._handleReactiveText(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncTextDirect(e, t) : e.textContent = t } _handleAsyncTextDirect(e, t) { const n = this._getPlaceholderConfig(e); e.textContent = n.text, e.className = n.className, n.style && (e.style.cssText = n.style), promisify(t).then((t => { e.textContent = t, e.classList.remove(n.className), n.style && (e.style.cssText = "") })).catch((t => { console.error(log.e("Async text failed:", t), "application"), e.textContent = `Error: ${t.message}`, e.classList.add("juris-async-error") })) } _handleReactiveText(e, t, n) { let s = null, r = !1; this._createReactiveUpdate(e, (() => { try { const n = t(e); this._isPromiseLike(n) ? promisify(n).then((t => { r && t === s || (e.textContent = t, s = t, r = !0) })).catch((e => console.error(log.e("Error in async reactive text:", e), "application"))) : r && n === s || (e.textContent = n, s = n, r = !0) } catch (e) { console.error(log.e("Error in reactive text function:", e), "application") } }), n) } _handleStyle(e, t, n) { if ("function" == typeof t) this._handleReactiveStyle(e, t, n); else if (this._isPromiseLike(t)) this._handleAsyncStyleDirect(e, t); else if ("object" == typeof t) for (const s in t) if (t.hasOwnProperty(s)) { const r = t[s]; "function" == typeof r ? this._handleReactiveStyleProperty(e, s, r, n) : e.style[s] = r } } _handleReactiveStyleProperty(e, t, n, s) { let r = null, i = !1; this._createReactiveUpdate(e, (() => { try { const s = n(e); this._isPromiseLike(s) ? promisify(s).then((n => { i && n === r || (e.style[t] = n, r = n, i = !0) })).catch((e => console.error(`Error in async reactive style property '${t}':`, e))) : i && s === r || (e.style[t] = s, r = s, i = !0) } catch (e) { console.error(`Error in reactive style property '${t}':`, e) } }), s) } _handleAsyncStyleDirect(e, t) { const n = this._getPlaceholderConfig(e); if (e.classList.add(n.className), n.style) { const t = n.style.split(";").filter((e => e.trim())); for (let n = 0; n < t.length; n++) { const s = t[n], [r, i] = s.split(":").map((e => e.trim())); r && i && (e.style[r] = i) } } promisify(t).then((t => { if (e.classList.remove(n.className), "object" == typeof t) { if (n.style) { const t = n.style.split(";").map((e => e.split(":")[0].trim())).filter((e => e)); for (let n = 0; n < t.length; n++)e.style.removeProperty(t[n]) } Object.assign(e.style, t) } })).catch((e => console.error(log.e("Async style failed:", e), "application"))) } _handleReactiveStyle(e, t, n) { let s = null, r = !1; this._createReactiveUpdate(e, (() => { try { const n = t(e); this._isPromiseLike(n) ? promisify(n).then((t => { r && deepEquals(t, s) || "object" == typeof t && (Object.assign(e.style, t), s = { ...t }, r = !0) })).catch((e => console.error(log.e("Error in async reactive style:", e), "application"))) : r && deepEquals(n, s) || "object" == typeof n && (Object.assign(e.style, n), s = { ...n }, r = !0) } catch (e) { console.error(log.e("Error in reactive style function:", e), "application") } }), n) } _createElementOptimized(e, t, n) { let s = this._getRecycledElement(e); s || (s = this.SVG_ELEMENTS.has(e.toLowerCase()) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e)), n && (this.elementCache.set(n, s), s._jurisKey = n); const r = [], i = []; return this._processProperties(s, t, r, i), (r.length > 0 || i.length > 0) && this.subscriptions.set(s, { subscriptions: r, eventListeners: i }), s } _processProperties(e, t, n, s) { for (const r in t) { if (!t.hasOwnProperty(r) || "key" === r) continue; const i = t[r]; switch (r) { case "children": this._handleChildren(e, i, n); break; case "text": this._handleText(e, i, n); break; case "innerHTML": "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : e.innerHTML = i; break; case "style": this._handleStyle(e, i, n); break; default: 111 === r.charCodeAt(0) && 110 === r.charCodeAt(1) ? this._handleEvent(e, r, i, s) : "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : this._setStaticAttribute(e, r, i) } } } _handleEvent(e, t, n, s) { if (console.debug(log.d("Event handler attached", { tagName: e.tagName, eventName: t }, "framework")), "onclick" === t) { const t = this.TOUCH_CONFIG; e.style.touchAction = t.touchAction, e.style.webkitTapHighlightColor = t.tapHighlight, e.style.webkitTouchCallout = t.touchCallout, e.addEventListener("click", n), s.push({ eventName: "click", handler: n }); let r = 0, i = !1, o = 0, a = 0; const c = e => { r = Date.now(), i = !1, e.touches?.[0] && (o = e.touches[0].clientX, a = e.touches[0].clientY) }, l = e => { if (e.touches?.[0]) { const n = Math.abs(e.touches[0].clientX - o), s = Math.abs(e.touches[0].clientY - a); (n > t.moveThreshold || s > t.moveThreshold) && (i = !0) } }, h = e => { const s = Date.now() - r; !i && s < t.timeThreshold && (e.preventDefault(), e.stopPropagation(), n(e)) }; e.addEventListener("touchstart", c, { passive: !0 }), e.addEventListener("touchmove", l, { passive: !0 }), e.addEventListener("touchend", h, { passive: !1 }), s.push({ eventName: "touchstart", handler: c }, { eventName: "touchmove", handler: l }, { eventName: "touchend", handler: h }) } else { const r = t.toLowerCase(), i = this.eventMap[r] || r.slice(2); e.addEventListener(i, n), s.push({ eventName: i, handler: n }) } } _handleReactiveAttribute(e, t, n, s) { let r = null, i = !1; this._createReactiveUpdate(e, (() => { try { const s = n(e); this._isPromiseLike(s) ? promisify(s).then((n => { i && deepEquals(n, r) || (this._setStaticAttribute(e, t, n), r = n, i = !0) })).catch((e => console.error(log.e(`Error in async reactive attribute '${t}':`, e), "application"))) : i && deepEquals(s, r) || (this._setStaticAttribute(e, t, s), r = s, i = !0) } catch (e) { console.error(log.e(`Error in reactive attribute '${t}':`, e), "application") } }), s) } _setStaticAttribute(e, t, n) { if (this.SKIP_ATTRS.has(t)) return; if ("function" == typeof n) return "value" !== t || "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName && "SELECT" !== e.tagName ? void console.warn(log.w(`Function value for attribute '${t}' should be handled reactively`), "application") : void (e.value = n(e)); if (this.BOOLEAN_ATTRS.has(t)) return void (n && "false" !== n ? e.setAttribute(t, "") : e.removeAttribute(t)); if ("http://www.w3.org/2000/svg" === e.namespaceURI) return void e.setAttribute(t, n); switch (t) { case "htmlFor": return void e.setAttribute("for", n); case "className": return void (e.className = n) }const s = t.charCodeAt(0); this.PRESERVED_ATTRIBUTES.has(t) || 100 === s && 45 === t.charCodeAt(4) || 97 === s && 45 === t.charCodeAt(4) || -1 !== t.indexOf("-") || -1 !== t.indexOf(":") ? e.setAttribute(t, n) : t in e && "function" != typeof e[t] ? e[t] = n : e.setAttribute(t, n) } _createReactiveUpdate(e, t, n) { const s = this.juris.stateManager.startTracking(), r = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = s; try { t(e) } catch (e) { console.error(log.e("Error capturing dependencies:", e), "application") } finally { this.juris.stateManager.currentTracking = r } const i = Array.from(s); for (let e = 0; e < i.length; e++) { const s = i[e], r = this.juris.stateManager.subscribeInternal(s, t); n.push(r) } } updateElementContent(e, t) { this._updateChildren(e, [t]) } setupIndicators(e, t) { this.placeholderConfigs.set(e, { ...this.defaultPlaceholder, ...t }) } cleanup(e) { console.debug(log.d("Cleaning up element", { tagName: e.tagName, hasSubscriptions: this.subscriptions.has(e) }, "framework")), this.juris.componentManager.cleanup(e); const t = this.subscriptions.get(e); if (t) { if (t.subscriptions) for (let e = 0; e < t.subscriptions.length; e++)try { t.subscriptions[e]() } catch (e) { console.warn(log.w("Error during subscription cleanup:", e), "framework") } if (t.eventListeners) for (let n = 0; n < t.eventListeners.length; n++) { const { eventName: s, handler: r } = t.eventListeners[n]; try { e.removeEventListener(s, r) } catch (e) { console.warn(log.w("Error during event listener cleanup:", e), "framework") } } this.subscriptions.delete(e) } e._jurisKey && this.elementCache.delete(e._jurisKey), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e); try { const t = e.children; for (let e = 0; e < t.length; e++)try { this.cleanup(t[e]) } catch (e) { console.warn(log.w("Error cleaning up child element:", e), "framework") } } catch (e) { console.warn(log.w("Error during children cleanup:", e), "framework") } } _generateKey(e, t) { if (t.key) return t.key; let n = e; for (let e = 0; e < this.KEY_PROPS.length; e++) { const s = this.KEY_PROPS[e]; t[s] && "function" != typeof t[s] && (n += `|${s}:${t[s]}`) } return n += `|hash:${this._hashProps(t)}`, n } _hashProps(e) { const t = JSON.stringify(e, ((e, t) => "function" == typeof t ? "[function]" : t)); let n = 0; for (let e = 0; e < t.length; e++) { n = (n << 5) - n + t.charCodeAt(e), n &= n } return Math.abs(n).toString(36) } _getRecycledElement(e) { const t = this.recyclePool.get(e); if (t?.length > 0) { const e = t.pop(); return this._resetElement(e), e } return null } _resetElement(e) { e.textContent = "", e.className = "", e.removeAttribute("style"); const t = Array.from(e.attributes); for (let n = 0; n < t.length; n++) { const s = t[n]; this.ATTRIBUTES_TO_KEEP.has(s.name) || e.removeAttribute(s.name) } } _canReuseElement(e, t, n) { return e.tagName.toLowerCase() === t.toLowerCase() } _updateElementProperties(e, t) { for (const n in t) if (t.hasOwnProperty(n) && !["key", "children", "text", "style"].includes(n)) { const s = t[n]; "function" != typeof s && this._setStaticAttribute(e, n, s) } } clearAsyncCache() { this.asyncCache.clear() } getAsyncStats() { return { cachedAsyncProps: this.asyncCache.size } } } class TemplateCompiler { parseTemplate(e) { const t = e.getAttribute("data-component"), n = e.getAttribute("data-context"), s = e.content, r = s.querySelector("script")?.textContent.trim() || "", i = document.createElement("div"); i.appendChild(s.cloneNode(!0)), i.querySelector("script")?.remove(); return { name: t, script: r, html: i.innerHTML.trim(), contextConfig: n } } htmlToObject(e) { const t = document.createElement("div"); return t.innerHTML = e, this.convertElement(t.firstElementChild) } convertElement(e) { const t = {}, n = e.tagName.toLowerCase(); t[n] = {}; for (const s of e.attributes) { let e = s.value; if (e.startsWith("{") && e.endsWith("}")) { const r = e.slice(1, -1); t[n][s.name] = { __FUNCTION__: r } } else t[n][s.name] = e } const s = Array.from(e.childNodes).map((e => this.convertNode(e))).filter((e => null !== e)); if (1 === s.length) { const e = s[0]; e && e.__REACTIVE_CHILDREN__ ? t[n].children = { __FUNCTION__: e.__REACTIVE_CHILDREN__ } : e && e.__REACTIVE_TEXT__ ? t[n].text = { __FUNCTION__: e.__REACTIVE_TEXT__ } : "string" == typeof e ? t[n].text = e : e && (t[n].children = [e]) } else s.length > 0 && (t[n].children = s); return t } convertNode(e) { if (e.nodeType === Node.TEXT_NODE) { const t = e.textContent.trim(); if (!t) return null; const n = t.match(/^\{children:(.+)\}$/s); if (n) return { __REACTIVE_CHILDREN__: n[1] }; const s = t.match(/^\{text:(.+)\}$/s); if (s) return { __REACTIVE_TEXT__: s[1] }; const r = t.match(/^\{(.+)\}$/s); return r ? { __REACTIVE_TEXT__: r[1] } : t } return e.nodeType === Node.ELEMENT_NODE ? this.convertElement(e) : null } generateContextDestructuring(e) { if (!e) return ""; return `const { ${e.split(",").map((e => e.trim())).join(", ")} } = context;` } generateComponent(e) { const t = this.objectToString(this.htmlToObject(e.html)), n = this.generateContextDestructuring(e.contextConfig); return `(props, context) => {\n${n ? `${n}\n${e.script}` : e.script}\n    return ${t};\n}` } objectToString(e, t = 0) { const n = "  ".repeat(t); if (e && e.__FUNCTION__) return e.__FUNCTION__; if ("string" == typeof e) return `'${e.replace(/'/g, "\\'")}'`; if ("number" == typeof e || "boolean" == typeof e) return String(e); if (Array.isArray(e)) { if (0 === e.length) return "[]"; return "[\n" + e.map((e => n + "  " + this.objectToString(e, t + 1))).join(",\n") + "\n" + n + "]" } if ("object" == typeof e && null !== e) { const s = Object.keys(e); if (0 === s.length) return "{}"; return "{\n" + s.map((s => { const r = this.objectToString(e[s], t + 1), i = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(s) ? s : `'${s}'`; return n + "  " + i + ": " + r })).join(",\n") + "\n" + n + "}" } return "null" } } class DOMEnhancer { constructor(e) { console.info(log.i("DOMEnhancer initialized", {}, "framework")), this.juris = e, this.enhancedElements = new WeakSet, this.containerEnhancements = new WeakMap, this.options = { debounceMs: 5, batchUpdates: !0, observeSubtree: !0, observeChildList: !0, observeNewElements: !0 }, this.enhancementRegistry = new Map, this.unifiedObserver = null, this.observerRefCount = 0, this.pendingEnhancements = new Set, this.enhancementTimer = null } enhance(e, t, n = {}) { if (e instanceof Element) return this.enhancedElements.has(e) ? () => { } : (this._enhanceElement(e, t, { ...this.options, ...n }), () => this._cleanupElement(e)); const s = { ...this.options, ...n }, r = e, i = this._determineEnhancementType(r, t); return console.info(log.i("Enhancement registered", { selector: r, type: i, hasSelectors: "selectors" === i, optionKeys: Object.keys(n) }, "framework")), this.enhancementRegistry.set(r, { definition: t, config: s, type: i }), this._enhanceExistingElements(r, t, s, i), !1 !== s.observeNewElements && (this._ensureUnifiedObserver(s), this.observerRefCount++), () => this._unenhance(r) } _determineEnhancementType(e, t) { return this._hasSelectorsCategory(t) ? "selectors" : "string" == typeof e && /^#[a-zA-Z][\w-]*$/.test(e) ? "id" : "simple" } _hasSelectorsCategory(e) { if (e?.selectors) return !0; if ("function" == typeof e) try { const t = e(this.juris.createContext()); return t?.selectors } catch (e) { return !1 } return !1 } _enhanceExistingElements(e, t, n, s) { if ("selectors" === s) this._enhanceExistingContainers(e, t, n); else { const s = document.querySelectorAll(e); n.batchUpdates && s.length > 1 ? this._batchEnhanceElements(Array.from(s), t, n) : s.forEach((e => this._enhanceElement(e, t, n))) } } _enhanceExistingContainers(e, t, n) { document.querySelectorAll(e).forEach((e => this._enhanceContainer(e, t, n))) } _batchEnhanceElements(e, t, n) { e.filter((e => !this.enhancedElements.has(e))).forEach((e => this._enhanceElement(e, t, n))) } _ensureUnifiedObserver(e) { this.unifiedObserver || (this.unifiedObserver = new MutationObserver((t => { e.debounceMs > 0 ? this._debouncedProcessMutations(t) : this._processUnifiedMutations(t) })), this.unifiedObserver.observe(document.body, { childList: e.observeChildList, subtree: e.observeSubtree })) } _processUnifiedMutations(e) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this._processNodeForAllEnhancements(e) })) })) } _processNodeForAllEnhancements(e) { this.enhancementRegistry.forEach((({ definition: t, config: n, type: s }, r) => { try { switch (s) { case "id": this._processIdEnhancement(e, r, t, n); break; case "simple": this._processSimpleEnhancement(e, r, t, n); break; case "selectors": this._processSelectorsEnhancement(e, r, t, n) } } catch (e) { console.error(log.e("Error processing enhancement:", e), "framework") } })) } _processIdEnhancement(e, t, n, s) { const r = t.slice(1); if (e.id === r) this._enhanceElement(e, n, s); else if (e.querySelector) { const r = e.querySelector(t); r && this._enhanceElement(r, n, s) } } _processSimpleEnhancement(e, t, n, s) { e.matches && e.matches(t) && this._enhanceElement(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceElement(e, n, s) })) } _processSelectorsEnhancement(e, t, n, s) { e.matches && e.matches(t) && this._enhanceContainer(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceContainer(e, n, s) })), this._enhanceNewElementsInContainers(e) } _debouncedProcessMutations(e) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this.pendingEnhancements.add({ node: e, timestamp: Date.now(), type: "unified" }) })) })), this.enhancementTimer && clearTimeout(this.enhancementTimer), this.enhancementTimer = setTimeout((() => { this._processPendingEnhancements(), this.enhancementTimer = null }), this.options.debounceMs) } _processPendingEnhancements() { const e = Array.from(this.pendingEnhancements); this.pendingEnhancements.clear(), e.forEach((({ node: e }) => { this._processNodeForAllEnhancements(e) })) } _enhanceNewElementsInContainers(e) { document.querySelectorAll("[data-juris-enhanced-container]").forEach((t => { if (!t.contains(e)) return; const n = this.containerEnhancements.get(t); n && n.forEach(((n, s) => { const { definition: r, enhancedElements: i } = n; e.matches && e.matches(s) && (this._enhanceSelectorElement(e, r, t, s), i.add(e)), e.querySelectorAll && e.querySelectorAll(s).forEach((e => { this.enhancedElements.has(e) || (this._enhanceSelectorElement(e, r, t, s), i.add(e)) })) })) })) } _enhanceContainer(e, t, n) { if (!this.enhancedElements.has(e)) try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced", Date.now()); let s = t; if ("function" == typeof t) { s = t(this.juris.createContext(e)) } if (!s?.selectors) return void console.warn(log.w('Selectors enhancement must have a "selectors" property'), "framework"); const r = new Map; this.containerEnhancements.set(e, r), this._applyContainerProperties(e, s), Object.entries(s.selectors).forEach((([t, s]) => { this._enhanceSelector(e, t, s, r, n) })) } catch (t) { console.error(log.e("Error enhancing container:", t), "application"), this.enhancedElements.delete(e) } } _applyContainerProperties(e, t) { const n = { ...t }; delete n.selectors, Object.keys(n).length > 0 && this._applyEnhancements(e, n) } _enhanceSelector(e, t, n, s, r) { const i = e.querySelectorAll(t), o = new Set; i.forEach((s => { this.enhancedElements.has(s) || (this._enhanceSelectorElement(s, n, e, t), o.add(s)) })), s.set(t, { definition: n, enhancedElements: o }) } _enhanceSelectorElement(e, t, n, s) { try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-selector", Date.now()); let n = t; if ("function" == typeof t) { if (n = t(this.juris.createContext(e)), !n || "object" != typeof n) return console.warn(log.w(`Selector '${s}' function must return a definition object`), "framework"), void this.enhancedElements.delete(e) } const r = this._processElementAwareFunctions(e, n); this._applyEnhancements(e, r) } catch (t) { console.error(log.e("Error enhancing selector element:", t), "application"), this.enhancedElements.delete(e) } } _processElementAwareFunctions(e, t) { const n = {}; return Object.entries(t).forEach((([t, s]) => { if ("function" == typeof s) if (t.startsWith("on")) n[t] = s; else if (s.length > 0) try { const r = s(this.juris.createContext(e)); n[t] = r && "object" == typeof r ? r : s } catch (e) { console.warn(log.w(`Error processing element-aware function '${t}':`, e), "framework"), n[t] = s } else n[t] = s; else n[t] = s })), n } _enhanceElement(e, t, n) { if (this.enhancedElements.has(e)) console.debug(log.d("Element already enhanced", { tagName: e.tagName }, "framework")); else try { console.debug(log.d("Enhancing element", { tagName: e.tagName, definitionKeys: Object.keys(t) }, "framework")), this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced", Date.now()); let s = t; if ("function" == typeof t) { if (s = t(this.juris.createContext(e)), !s || "object" != typeof s) return console.warn(log.w("Enhancement function must return a definition object"), "framework"), void this.enhancedElements.delete(e) } this._applyEnhancements(e, s), n.onEnhanced?.(e, this.juris.createContext(e)) } catch (t) { console.error(log.e("Element enhancement failed", { tagName: e.tagName, error: t.message }, "framework")), this.enhancedElements.delete(e) } } _applyEnhancements(e, t) { const n = [], s = [], r = this.juris.domRenderer; Object.keys(t).forEach((i => { const o = t[i]; try { "children" === i ? this._handleChildren(e, o, n, r) : "text" === i ? r._handleText(e, o, n) : "innerHTML" === i ? this._handleInnerHTML(e, o, n, r) : "style" === i ? r._handleStyle(e, o, n) : i.startsWith("on") ? r._handleEvent(e, i, o, s) : "function" == typeof o ? r._handleReactiveAttribute(e, i, o, n) : r._setStaticAttribute(e, i, o) } catch (e) { console.error(log.e(`Error processing enhancement property '${i}':`, e), "framework") } })), (n.length > 0 || s.length > 0) && this.juris.domRenderer.subscriptions.set(e, { subscriptions: n, eventListeners: s }) } _handleChildren(e, t, n, s) { s.isFineGrained() ? s._handleChildrenFineGrained(e, t, n) : s._handleChildrenOptimized(e, t, n) } _handleInnerHTML(e, t, n, s) { "function" == typeof t ? s._handleReactiveAttribute(e, "innerHTML", t, n) : e.innerHTML = t } _unenhance(e) { const t = this.enhancementRegistry.get(e); t && (this.observerRefCount--, 0 === this.observerRefCount && this.unifiedObserver && (this.unifiedObserver.disconnect(), this.unifiedObserver = null), this.enhancementRegistry.delete(e), "selectors" === t.type ? document.querySelectorAll(`${e}[data-juris-enhanced-container]`).forEach((e => { this._cleanupContainer(e) })) : document.querySelectorAll(`${e}[data-juris-enhanced]`).forEach((e => { this._cleanupElement(e) }))) } _cleanupContainer(e) { const t = this.containerEnhancements.get(e); t && (t.forEach((e => { e.enhancedElements.forEach((e => this._cleanupElement(e))) })), this.containerEnhancements.delete(e)), this._cleanupElement(e), e.removeAttribute("data-juris-enhanced-container") } _cleanupElement(e) { this.juris.domRenderer.cleanup(e), this.enhancedElements.delete(e), e.removeAttribute("data-juris-enhanced"), e.removeAttribute("data-juris-enhanced-selector") } configure(e) { Object.assign(this.options, e) } getStats() { const e = document.querySelectorAll("[data-juris-enhanced]").length, t = document.querySelectorAll("[data-juris-enhanced-container]").length, n = document.querySelectorAll("[data-juris-enhanced-selector]").length; return { enhancementRules: this.enhancementRegistry.size, activeObserver: this.unifiedObserver ? 1 : 0, observerRefCount: this.observerRefCount, pendingEnhancements: this.pendingEnhancements.size, enhancedElements: e, enhancedContainers: t, enhancedSelectors: n, totalEnhanced: e + n } } destroy() { this.unifiedObserver && (this.unifiedObserver.disconnect(), this.unifiedObserver = null), this.enhancementRegistry.clear(), this.observerRefCount = 0, this.enhancementTimer && (clearTimeout(this.enhancementTimer), this.enhancementTimer = null), document.querySelectorAll("[data-juris-enhanced], [data-juris-enhanced-selector]").forEach((e => { this._cleanupElement(e) })), document.querySelectorAll("[data-juris-enhanced-container]").forEach((e => { this._cleanupContainer(e) })), this.pendingEnhancements.clear() } } class Juris { static _inGlobal = !1; constructor(e = {}) { e.logLevel && this.setupLogging(e.logLevel), console.info(log.i("Juris framework initializing", { hasServices: !!e.services, hasLayout: !!e.layout, hasStates: !!e.states, hasComponents: !!e.components, renderMode: e.renderMode || "auto" }, "framework")), this.services = e.services || {}, this.layout = e.layout, this.stateManager = new StateManager(e.states || {}, e.middleware || []), this.headlessManager = new HeadlessManager(this), this.componentManager = new ComponentManager(this), this.domRenderer = new DOMRenderer(this), this.domEnhancer = new DOMEnhancer(this), this.templateCompiler = new TemplateCompiler, this.headlessAPIs = {}, !1 !== e.autoCompileTemplates && this.compileTemplates(), e.headlessComponents && Object.entries(e.headlessComponents).forEach((([e, t]) => { "function" == typeof t ? this.headlessManager.register(e, t) : this.headlessManager.register(e, t.fn, t.options) })), e.placeholders && Object.entries(e.placeholders).forEach((([e, t]) => { this.domRenderer.setupIndicators(e, t) })), e.defaultPlaceholder && (this.domRenderer.defaultPlaceholder = { ...this.domRenderer.defaultPlaceholder, ...e.defaultPlaceholder }), this.headlessManager.initializeQueued(), "fine-grained" === e.renderMode ? this.domRenderer.setRenderMode("fine-grained") : "batch" === e.renderMode && this.domRenderer.setRenderMode("batch"), e.components && Object.entries(e.components).forEach((([e, t]) => { this.componentManager.register(e, t) })), console.info(log.i("Juris framework initialized", { componentsCount: this.componentManager.components.size, headlessCount: this.headlessManager.components.size }, "framework")), "undefined" == typeof requestIdleCallback && (window.requestIdleCallback = function (e, t) { const n = Date.now(); return setTimeout((function () { e({ didTimeout: !1, timeRemaining: function () { return Math.max(0, 50 - (Date.now() - n)) } }) }), 1) }) } _detectGlobalAndWarn() { Juris._done || (requestIdleCallback || setTimeout)((() => { if (!Juris._inGlobal) { Juris._inGlobal = !0; for (let e in globalThis) globalThis[e] instanceof Juris && console.warn(` JURIS GLOBAL: '${e}'`) } })) } compileTemplates() { const templates = document.querySelectorAll("template[data-component]"), components = {}; templates.forEach((template => { const parsed = this.templateCompiler.parseTemplate(template), componentCode = this.templateCompiler.generateComponent(parsed); components[parsed.name] = eval(`(${componentCode})`) })), Object.entries(components).forEach((([e, t]) => { this.registerComponent(e, t) })) } setupLogging(e) { const t = { debug: 0, info: 1, warn: 2, error: 3 }[e] || 1; t > 0 && (console.debug = () => { }), t > 1 && (console.log("Juris logging initialized at level:", e), console.log('To change log level, use juris.setupLogging("newLevel") or set logLevel in config'), console.log = () => { }, console.info = () => { }) } setupIndicators(e, t) { this.domRenderer.setupIndicators(e, t) } createHeadlessContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), executeBatch: e => this.executeBatch(e), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, headless: this.headlessManager.context, isSSR: "undefined" == typeof window, ...this.headlessAPIs || {}, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t) }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), getHeadlessStatus: () => this.headlessManager.getStatus() }, juris: this, logger: { log: log, lwarn: log.w, error: log.e, info: log.i, debug: log.d, subscribe: logSub, unsubscribe: logUnsub } }; return e && (t.element = e), t } executeBatch(e) { return this.stateManager.executeBatch(e) } createWebComponent(e, t, n = {}) { if (console.info(log.i("Creating WebComponent", { name: e, hasOptions: Object.keys(n).length > 0 }, "framework")), !e.includes("-")) throw new Error(`WebComponent name "${e}" must contain a hyphen (-)`); if (customElements.get(e)) return console.warn(log.w("WebComponent already registered", { name: e }, "framework")), customElements.get(e); const s = this._createWebComponentClass(e, t, n); return customElements.define(e, s), console.info(log.i("WebComponent registered", { name: e, className: s.name }, "framework")), s } createWebComponents(e, t = {}) { const n = {}; return Object.entries(e).forEach((([e, s]) => { const r = s.options ? { ...t, ...s.options } : t, i = s.component || s.render || s; n[e] = this.createWebComponent(e, i, r) })), n } _createWebComponentClass(e, t, n) { const s = this, { shadowMode: r = "open", attributes: i = [], styles: o = "", enhanceMode: a = !1, autoConnect: c = !0, stateNamespace: l = null, contextProvider: h = null } = n; return class extends HTMLElement { static get observedAttributes() { return i } constructor() { super(), this.componentName = e, this.componentId = `${e}-${Math.random().toString(36).substr(2, 9)}`, this.isJurisComponent = !0, this._mounted = !1, this._unsubscribes = [], "function" == typeof t ? this.componentFn = t : "object" == typeof t && (this.componentConfig = t, this.componentFn = t.render || t.component), console.debug(log.d("WebComponent instance created", { name: e, componentId: this.componentId }, "framework")) } connectedCallback() { c && (console.debug(log.d("WebComponent connecting", { name: e, componentId: this.componentId }, "framework")), this._setupShadowDOM(), this._setupJurisIntegration(), this._setupAttributes(), this._setupStyles(), this.componentConfig?.hooks?.onConnect && this.componentConfig.hooks.onConnect.call(this, this.jurisContext), this.render(), this._mounted = !0, this.componentConfig?.hooks?.onMount && requestAnimationFrame((() => { this.componentConfig.hooks.onMount.call(this, this.jurisContext) }))) } disconnectedCallback() { console.debug(log.d("WebComponent disconnecting", { name: e, componentId: this.componentId }, "framework")), this._mounted = !1, this._unsubscribes.forEach((e => { try { e() } catch (e) { console.warn(log.w("Error during subscription cleanup:", e), "framework") } })), this._unsubscribes = [], this.componentConfig?.hooks?.onUnmount && this.componentConfig.hooks.onUnmount.call(this, this.jurisContext), this.stateKey && !1 !== n.cleanupState && s.stateManager.setState(this.stateKey, void 0) } attributeChangedCallback(e, t, r) { if (t !== r && this._mounted) { if (console.debug(log.d("Attribute changed", { name: e, oldValue: t, newValue: r }, "framework")), this.stateKey) { const t = s.getState(this.stateKey, {}); s.setState(this.stateKey, { ...t, [e]: this._parseAttributeValue(r) }) } this.componentConfig?.hooks?.onAttributeChange && this.componentConfig.hooks.onAttributeChange.call(this, e, t, r, this.jurisContext), !1 !== n.rerenderOnAttributeChange && this.render() } } _setupShadowDOM() { a ? this.renderRoot = this : (this.attachShadow({ mode: r }), this.renderRoot = this.shadowRoot) } _setupJurisIntegration() { this.stateKey = l || `webcomponents.${e.replace(/-/g, "_")}.${this.componentId}`; const t = this._getInitialState(); s.setState(this.stateKey, t), this.jurisContext = this._createJurisContext(); const r = s.subscribe(this.stateKey, (() => { this._mounted && !1 !== n.autoRerender && (console.debug(log.d("Auto re-rendering due to state change", { componentId: this.componentId }, "framework")), this.render()) })); this._unsubscribes.push(r) } _createJurisContext() { return { ...h ? h.call(this, s.createContext(this)) : s.createContext(this), component: { name: this.componentName, id: this.componentId, element: this, renderRoot: this.renderRoot, shadowRoot: this.shadowRoot, getState: (e, t) => { const n = e ? `${this.stateKey}.${e}` : this.stateKey; return s.getState(n, t) }, setState: (e, t) => { if ("object" == typeof e) { const t = s.getState(this.stateKey, {}); s.setState(this.stateKey, { ...t, ...e }) } else { const n = e ? `${this.stateKey}.${e}` : this.stateKey; s.setState(n, t) } }, updateState: e => { const t = s.getState(this.stateKey, {}); s.setState(this.stateKey, { ...t, ...e }) }, getAttribute: (e, t = null) => this.getAttribute(e) || t, setAttribute: (e, t) => { this.setAttribute(e, t) }, emit: (e, t = {}, n = {}) => { const s = new CustomEvent(e, { detail: t, bubbles: !0, composed: !0, ...n }); return this.dispatchEvent(s), s }, getSlot: (e = "") => e ? this.querySelector(`[slot="${e}"]`) : this.querySelector(":not([slot])"), getAllSlots: () => { const e = {}; return this.querySelectorAll("[slot]").forEach((t => { const n = t.getAttribute("slot"); e[n] || (e[n] = []), e[n].push(t) })), e }, onMount: e => { this._mounted ? e.call(this, this.jurisContext) : (this._onMountCallbacks = this._onMountCallbacks || [], this._onMountCallbacks.push(e)) }, onUnmount: e => { this._onUnmountCallbacks = this._onUnmountCallbacks || [], this._onUnmountCallbacks.push(e) } } } } _getInitialState() { let e = {}; return this.componentConfig?.initialState && (e = "function" == typeof this.componentConfig.initialState ? this.componentConfig.initialState.call(this) : { ...this.componentConfig.initialState }), this.componentFn?.getInitialState && (e = { ...e, ...this.componentFn.getInitialState.call(this) }), i.forEach((t => { this.hasAttribute(t) && (e[t] = this._parseAttributeValue(this.getAttribute(t))) })), e } _setupAttributes() { i.forEach((e => { if (this.hasAttribute(e)) { const t = this._parseAttributeValue(this.getAttribute(e)); this.jurisContext.component.setState(e, t) } })) } _setupStyles() { if (o && this.shadowRoot) { const e = document.createElement("style"); e.textContent = o, this.shadowRoot.appendChild(e) } } _parseAttributeValue(e) { if (null == e) return e; if ("true" === e) return !0; if ("false" === e) return !1; if ("" === e) return !0; if (!isNaN(e) && !isNaN(parseFloat(e))) return parseFloat(e); try { return JSON.parse(e) } catch { return e } } render() { try { let t; if (console.debug(log.d("Rendering WebComponent", { componentId: this.componentId }, "framework")), this.componentFn) t = this.componentFn.call(this, this._getProps(), this.jurisContext); else { if (!this.componentConfig?.template) return void console.warn(log.w("No render method found for WebComponent", { name: e }, "framework")); t = this.componentConfig.template.call(this, this._getProps(), this.jurisContext) } if (t?.then) return void this._handleAsyncRender(t); if (t) { const e = s.objectToHtml(t); if (this.renderRoot.innerHTML = "", this.shadowRoot && o) { const e = document.createElement("style"); e.textContent = o, this.renderRoot.appendChild(e) } this.renderRoot.appendChild(e) } } catch (t) { console.error(log.e("WebComponent render error", { name: e, componentId: this.componentId, error: t.message }, "framework")), this._renderError(t) } } _handleAsyncRender(e) { this.renderRoot.innerHTML = '<div class="juris-loading">Loading...</div>', s.promisify(e).then((e => { if (this._mounted) { const t = s.objectToHtml(e); this.renderRoot.innerHTML = "", this.renderRoot.appendChild(t) } })).catch((e => { console.error(log.e("Async render error", { error: e.message }, "framework")), this._renderError(e) })) } _renderError(e) { const t = document.createElement("div"); t.style.cssText = "color: red; padding: 10px; border: 1px solid red; background: #fee;", t.textContent = `Component Error: ${e.message}`, this.renderRoot.innerHTML = "", this.renderRoot.appendChild(t) } _getProps() { const e = {}; i.forEach((t => { this.hasAttribute(t) && (e[t] = this._parseAttributeValue(this.getAttribute(t))) })); const t = s.getState(this.stateKey, {}); return Object.assign(e, t), e } forceRender() { this.render() } getJurisContext() { return this.jurisContext } getComponentState() { return s.getState(this.stateKey, {}) } updateComponentState(e) { this.jurisContext.component.updateState(e) } } } createContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), executeBatch: e => this.executeBatch(e), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, ...this.headlessAPIs || {}, headless: this.headlessManager.context, isSSR: "undefined" == typeof window, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t), getHeadlessAPI: e => this.headlessManager.getAPI(e), getAllHeadlessAPIs: () => this.headlessManager.getAllAPIs() }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), setRenderMode: e => this.setRenderMode(e), getRenderMode: () => this.getRenderMode(), isFineGrained: () => this.isFineGrained(), isBatchMode: () => this.isBatchMode(), getHeadlessStatus: () => this.headlessManager.getStatus(), objectToHtml: e => this.objectToHtml(e) }, objectToHtml: e => this.objectToHtml(e), setupIndicators: (e, t) => this.setupIndicators(e, t), juris: this, logger: { log: log, lwarn: log.w, error: log.e, info: log.i, debug: log.d, subscribe: logSub, unsubscribe: logUnsub } }; return e && (t.element = e), t } getState(e, t, n) { return this.stateManager.getState(e, t, n) } setState(e, t, n) { return console.debug(log.d("Public setState called", { path: e }, "application")), this.stateManager.setState(e, t, n) } subscribe(e, t, n = !0) { return this.stateManager.subscribe(e, t, n) } subscribeExact(e, t) { return this.stateManager.subscribeExact(e, t) } registerComponent(e, t) { return console.info(log.i("Public component registration", { name: e }, "application")), this.componentManager.register(e, t) } registerHeadlessComponent(e, t, n) { return this.headlessManager.register(e, t, n) } getComponent(e) { return this.componentManager.components.get(e) } getHeadlessComponent(e) { return this.headlessManager.getInstance(e) } initializeHeadlessComponent(e, t) { return this.headlessManager.initialize(e, t) } setRenderMode(e) { this.domRenderer.setRenderMode(e) } getRenderMode() { return this.domRenderer.getRenderMode() } isFineGrained() { return this.domRenderer.isFineGrained() } isBatchMode() { return this.domRenderer.isBatchMode() } _updateComponentContexts() { this.headlessAPIs } registerAndInitHeadless(e, t, n = {}) { return this.headlessManager.register(e, t, n), this.headlessManager.initialize(e, n) } getHeadlessStatus() { return this.headlessManager.getStatus() } objectToHtml(e) { return this.domRenderer.render(e) } render(e = "#app") { const t = performance.now(); console.info(log.i("Render started with template compilation", { container: e }, "application")); const n = "string" == typeof e ? document.querySelector(e) : e; if (!n) return void console.error(log.e("Render container not found", { container: e }, "application")); const s = this.getState("isHydration", !1); try { s ? this._renderWithHydration(n) : this._renderImmediate(n); const e = performance.now() - t; console.info(log.i("Render completed with templates", { duration: `${e.toFixed(2)}ms`, isHydration: s }, "application")) } catch (t) { console.error(log.e("Render failed", { error: t.message, container: e }, "application")), this._renderError(n, t) } } _renderImmediate = function (e) { e.innerHTML = ""; const t = this.domRenderer.render(this.layout); t && e.appendChild(t) }; _renderWithHydration = async function (e) { const t = document.createElement("div"); t.style.cssText = "position: absolute; left: -9999px; visibility: hidden;", document.body.appendChild(t); try { startTracking(); const n = this.domRenderer.render(this.layout); for (n && t.appendChild(n), await onAllComplete(), e.innerHTML = ""; t.firstChild;)e.appendChild(t.firstChild); this.headlessManager.initializeQueued() } finally { stopTracking(), document.body.removeChild(t) } }; _renderError(e, t) { const n = document.createElement("div"); n.style.cssText = "color: red; border: 2px solid red; padding: 16px; margin: 8px; background: #ffe6e6;", n.innerHTML = `\n                <h3>Render Error</h3>\n                <p><strong>Message:</strong> ${t.message}</p>\n                <pre style="background: #f5f5f5; padding: 8px; overflow: auto;">${t.stack || ""}</pre>\n            `, e.appendChild(n) } enhance(e, t, n) { return this.domEnhancer.enhance(e, t, n) } configureEnhancement(e) { return this.domEnhancer.configure(e) } getEnhancementStats() { return this.domEnhancer.getStats() } cleanup() { console.info(log.i("Framework cleanup initiated", {}, "application")), this.headlessManager.cleanup() } destroy() { console.info(log.i("Framework destruction initiated", {}, "application")), this.cleanup(), this.domEnhancer.destroy(), this.stateManager.subscribers.clear(), this.stateManager.externalSubscribers.clear(), this.componentManager.components.clear(), this.headlessManager.components.clear(), console.info(log.i("Framework destroyed", {}, "application")) } } "undefined" != typeof window ? (window.Juris = Juris, window.jurisVersion = jurisVersion, window.jurisLinesOfCode = jurisLinesOfCode, window.jurisMinifiedSize = jurisMinifiedSize) : "undefined" != typeof module && module.exports ? (module.exports = Juris, module.exports.jurisVersion = jurisVersion, module.exports.jurisLinesOfCode = jurisLinesOfCode, module.exports.jurisMinifiedSize = jurisMinifiedSize) : "undefined" != typeof exports && (exports.Juris = Juris, exports.jurisVersion = jurisVersion, exports.jurisLinesOfCode = jurisLinesOfCode, exports.jurisMinifiedSize = jurisMinifiedSize) })();