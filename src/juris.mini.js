!function () { "use strict"; const e = e => "string" == typeof e && e.trim().length > 0 && !e.includes(".."), t = e => e.split(".").filter(Boolean), n = (e, t) => { if (e === t) return !0; if (null == e || null == t || typeof e != typeof t) return !1; if ("object" == typeof e) { if (Array.isArray(e) !== Array.isArray(t)) return !1; const s = Object.keys(e), r = Object.keys(t); return s.length === r.length && s.every((s => r.includes(s) && n(e[s], t[s]))) } return !1 }, { promisify: s, startTracking: r, stopTracking: i, onAllComplete: a } = (() => { const e = new Set; let t = !1; const n = new Set, s = () => { 0 === e.size && n.size > 0 && n.forEach((e => e())) }; return { promisify: n => { const r = n?.then ? n : Promise.resolve(n); return t && r !== n && (e.add(r), r.finally((() => { e.delete(r), setTimeout(s, 0) }))), r }, startTracking: () => { t = !0, e.clear() }, stopTracking: () => { t = !1, n.clear() }, onAllComplete: t => (n.add(t), 0 === e.size && setTimeout(t, 0), () => n.delete(t)) } })(); class StateManager { constructor(e = {}, t = []) { this.state = { ...e }, this.middleware = [...t], this.subscribers = new Map, this.externalSubscribers = new Map, this.currentTracking = null, this.isUpdating = !1, this.updateQueue = [], this.batchTimeout = null, this.batchUpdateInProgress = !1, this.maxBatchSize = 50, this.batchDelayMs = 0, this.batchingEnabled = !0, this.initialState = JSON.parse(JSON.stringify(e)), this.maxUpdateDepth = 50, this.updateDepth = 0, this.currentlyUpdating = new Set } reset(e = []) { const t = {}; e.forEach((e => { const n = this.getState(e); null !== n && (t[e] = n) })), this.state = {}, Object.entries(this.initialState).forEach((([e, t]) => this.setState(e, JSON.parse(JSON.stringify(t))))), Object.entries(t).forEach((([e, t]) => this.setState(e, t))) } getState(n, s = null, r = !0) { if (!e(n)) return s; r && this.currentTracking?.add(n); const i = t(n); let a = this.state; for (const e of i) { if (void 0 === a?.[e]) return s; a = a[e] } return a } setState(t, n, s = {}) { e(t) && !this._hasCircularUpdate(t) && (this.batchingEnabled && this.batchDelayMs > 0 ? this._queueUpdate(t, n, s) : this._setStateImmediate(t, n, s)) } _setStateImmediate(e, s, r = {}) { const i = this.getState(e); let a = s; for (const t of this.middleware) try { const n = t({ path: e, oldValue: i, newValue: a, context: r, state: this.state }); void 0 !== n && (a = n) } catch (e) { console.error("Middleware error:", e) } if (n(i, a)) return; const o = t(e); let c = this.state; for (let e = 0; e < o.length - 1; e++) { const t = o[e]; null != c[t] && "object" == typeof c[t] || (c[t] = {}), c = c[t] } c[o[o.length - 1]] = a, this.isUpdating || (this.isUpdating = !0, this.currentlyUpdating || (this.currentlyUpdating = new Set), this.currentlyUpdating.add(e), this._notifySubscribers(e, a, i), this._notifyExternalSubscribers(e, a, i), this.currentlyUpdating.delete(e), this.isUpdating = !1) } _queueUpdate(e, t, n) { this.updateQueue.push({ path: e, value: t, context: n, timestamp: Date.now() }), this.updateQueue.length > 2 * this.maxBatchSize ? this._processBatchedUpdates() : this.batchTimeout || (this.batchTimeout = setTimeout((() => this._processBatchedUpdates()), this.batchDelayMs)) } _processBatchedUpdates() { if (this.batchUpdateInProgress || 0 === this.updateQueue.length) return; this.batchUpdateInProgress = !0, this.batchTimeout && (clearTimeout(this.batchTimeout), this.batchTimeout = null); const e = Math.min(this.maxBatchSize, this.updateQueue.length), t = this.updateQueue.splice(0, e); try { const e = new Map; t.forEach((t => e.set(t.path, t))), e.forEach((e => this._setStateImmediate(e.path, e.value, e.context))) } catch (e) { console.error("Error processing batched updates:", e) } finally { this.batchUpdateInProgress = !1, this.updateQueue.length > 0 && setTimeout((() => this._processBatchedUpdates()), 0) } } configureBatching(e = {}) { this.maxBatchSize = e.maxBatchSize || this.maxBatchSize, this.batchDelayMs = void 0 !== e.batchDelayMs ? e.batchDelayMs : this.batchDelayMs, void 0 !== e.enabled && (this.batchingEnabled = e.enabled) } subscribe(e, t, n = !0) { this.externalSubscribers.has(e) || this.externalSubscribers.set(e, new Set); const s = { callback: t, hierarchical: n }; return this.externalSubscribers.get(e).add(s), () => { const t = this.externalSubscribers.get(e); t && (t.delete(s), 0 === t.size && this.externalSubscribers.delete(e)) } } subscribeExact(e, t) { return this.subscribe(e, t, !1) } subscribeInternal(e, t) { return this.subscribers.has(e) || this.subscribers.set(e, new Set), this.subscribers.get(e).add(t), () => { const n = this.subscribers.get(e); n && (n.delete(t), 0 === n.size && this.subscribers.delete(e)) } } _notifySubscribers(e, n, s) { this._triggerPathSubscribers(e); const r = t(e); for (let e = r.length - 1; e > 0; e--)this._triggerPathSubscribers(r.slice(0, e).join(".")); const i = e ? e + "." : ""; new Set([...this.subscribers.keys(), ...this.externalSubscribers.keys()]).forEach((t => { t.startsWith(i) && t !== e && this._triggerPathSubscribers(t) })) } _notifyExternalSubscribers(e, t, n) { this.externalSubscribers.forEach(((s, r) => { s.forEach((({ callback: s, hierarchical: i }) => { if (i ? e === r || e.startsWith(r + ".") : e === r) try { s(t, n, e) } catch (e) { console.error("External subscriber error:", e) } })) })) } _triggerPathSubscribers(e) { const t = this.subscribers.get(e); t && new Set(t).forEach((e => { try { const t = this.currentTracking, n = new Set; this.currentTracking = n, e(), this.currentTracking = t, n.forEach((t => { const n = this.subscribers.get(t); n && n.has(e) || this.subscribeInternal(t, e) })) } catch (e) { console.error("Subscriber error:", e), this.currentTracking = oldTracking } })) } _hasCircularUpdate(e) { return this.currentlyUpdating || (this.currentlyUpdating = new Set), !!this.currentlyUpdating.has(e) && (console.warn(`Circular dependency detected for path: ${e}`), !0) } startTracking() { const e = new Set; return this.currentTracking = e, e } endTracking() { const e = this.currentTracking; return this.currentTracking = null, e || new Set } } class HeadlessManager { constructor(e) { this.juris = e, this.components = new Map, this.instances = new Map, this.context = {}, this.initQueue = new Set, this.lifecycleHooks = new Map } register(e, t, n = {}) { this.components.set(e, { fn: t, options: n }), n.autoInit && this.initQueue.add(e) } initialize(e, t = {}) { const n = this.components.get(e); if (!n) return null; try { const s = this.juris.createHeadlessContext(), r = n.fn(t, s); return r && "object" == typeof r ? (this.instances.set(e, r), r.hooks && this.lifecycleHooks.set(e, r.hooks), r.api && (this.context[e] = r.api, this.juris.headlessAPIs || (this.juris.headlessAPIs = {}), this.juris.headlessAPIs[e] = r.api, this.juris._updateComponentContexts()), r.hooks?.onRegister?.(), r) : null } catch (t) { return console.error(`Error initializing headless component '${e}':`, t), null } } initializeQueued() { this.initQueue.forEach((e => { if (!this.instances.has(e)) { const t = this.components.get(e); this.initialize(e, t.options || {}) } })), this.initQueue.clear() } getInstance(e) { return this.instances.get(e) } getAPI(e) { return this.context[e] } getAllAPIs() { return { ...this.context } } reinitialize(e, t = {}) { const n = this.instances.get(e); if (n?.hooks?.onUnregister) try { n.hooks.onUnregister() } catch (t) { console.error(`Error in onUnregister for '${e}':`, t) } return this.context[e] && delete this.context[e], this.juris.headlessAPIs?.[e] && delete this.juris.headlessAPIs[e], this.instances.delete(e), this.lifecycleHooks.delete(e), this.initialize(e, t) } cleanup() { this.instances.forEach(((e, t) => { if (e.hooks?.onUnregister) try { e.hooks.onUnregister() } catch (e) { console.error(`Error in onUnregister for '${t}':`, e) } })), this.instances.clear(), this.context = {}, this.lifecycleHooks.clear(), this.juris.headlessAPIs && (this.juris.headlessAPIs = {}) } getStatus() { return { registered: Array.from(this.components.keys()), initialized: Array.from(this.instances.keys()), queued: Array.from(this.initQueue), apis: Object.keys(this.context) } } } class ComponentManager { constructor(e) { this.juris = e, this.components = new Map, this.instances = new WeakMap, this.componentCounters = new Map, this.componentStates = new WeakMap, this.asyncPlaceholders = new WeakMap, this.asyncPropsCache = new Map } register(e, t) { this.components.set(e, t) } create(e, t = {}) { const n = this.components.get(e); if (!n) return console.error(`Component '${e}' not found`), null; try { if (this._hasAsyncProps(t)) return this._createWithAsyncProps(e, n, t); const { componentId: r, componentStates: i } = this._setupComponent(e), a = n(t, this._createComponentContext(r, i)); return a?.then ? this._handleAsyncComponent(s(a), e, t, i) : this._processComponentResult(a, e, t, i) } catch (t) { return console.error(`Error creating component '${e}':`, t), this._createErrorElement(t) } } _setupComponent(e) { this.componentCounters.has(e) || this.componentCounters.set(e, 0); const t = this.componentCounters.get(e) + 1; this.componentCounters.set(e, t); return { componentId: `${e}_${t}`, componentStates: new Set } } _createComponentContext(e, t) { const n = this.juris.createContext(); return n.newState = (n, s) => { const r = `__local.${e}.${n}`; return this.juris.stateManager.getState(r, Symbol("not-found")) === Symbol("not-found") && this.juris.stateManager.setState(r, s), t.add(r), [() => this.juris.stateManager.getState(r, s), e => this.juris.stateManager.setState(r, e)] }, n } _hasAsyncProps(e) { return Object.values(e).some((e => e?.then)) } _createWithAsyncProps(e, t, n) { const s = this._createPlaceholder(`Loading ${e}...`, "juris-async-props-loading"); return this.asyncPlaceholders.set(s, { name: e, props: n, type: "async-props" }), this._resolveAsyncProps(n).then((n => { try { const r = this._createSyncComponent(e, t, n); r && s.parentNode && s.parentNode.replaceChild(r, s), this.asyncPlaceholders.delete(s) } catch (e) { this._replaceWithError(s, e) } })).catch((e => this._replaceWithError(s, e))), s } async _resolveAsyncProps(e) { const t = this._generateCacheKey(e), n = this.asyncPropsCache.get(t); if (n && Date.now() - n.timestamp < 5e3) return n.props; const s = {}; for (const [t, n] of Object.entries(e)) if (n?.then) try { s[t] = await n } catch (e) { s[t] = { __asyncError: e.message } } else s[t] = n; return this.asyncPropsCache.set(t, { props: s, timestamp: Date.now() }), s } _generateCacheKey(e) { return JSON.stringify(e, ((e, t) => t?.then ? "[Promise]" : t)) } _createSyncComponent(e, t, n) { const { componentId: r, componentStates: i } = this._setupComponent(e), a = t(n, this._createComponentContext(r, i)); return a?.then ? this._handleAsyncComponent(s(a), e, n, i) : this._processComponentResult(a, e, n, i) } _handleAsyncComponent(e, t, n, s) { const r = this._createPlaceholder(`Loading ${t}...`, "juris-async-loading"); return this.asyncPlaceholders.set(r, { name: t, props: n, componentStates: s }), e.then((e => { try { const i = this._processComponentResult(e, t, n, s); i && r.parentNode && r.parentNode.replaceChild(i, r), this.asyncPlaceholders.delete(r) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } _processComponentResult(e, t, n, r) { if (e && "object" == typeof e) { if (this._hasLifecycleHooks(e)) return this._createLifecycleComponent(e, t, n, r); if ("function" == typeof e.render && !this._hasLifecycleHooks(e)) { const n = e.render(); if (n?.then) return this._handleAsyncRender(s(n), t, r, e.indicator); const i = this.juris.domRenderer.render(n); return i && r.size > 0 && this.componentStates.set(i, r), i } const i = Object.keys(e); if (1 === i.length && "string" == typeof i[0] && i[0].length > 0) { const t = this.juris.domRenderer.render(e); return t && r.size > 0 && this.componentStates.set(t, r), t } } const i = this.juris.domRenderer.render(e); return i && r.size > 0 && this.componentStates.set(i, r), i } _hasLifecycleHooks(e) { return e.hooks && (e.hooks.onMount || e.hooks.onUpdate || e.hooks.onUnmount) || e.onMount || e.onUpdate || e.onUnmount } _handleAsyncRender(e, t, n, s = null) { const r = s ? this.juris.domRenderer.render(s) : this._createPlaceholder(`Loading ${t}...`, "juris-async-loading"); return e.then((e => { try { const t = this.juris.domRenderer.render(e); t && n.size > 0 && this.componentStates.set(t, n), r.parentNode && r.parentNode.replaceChild(t, r) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } _createLifecycleComponent(e, t, n, r) { const i = { name: t, props: n, hooks: e.hooks || {}, api: e.api || {}, render: e.render }, a = i.render(); if (a?.then) return this._handleAsyncLifecycleRender(s(a), i, r); const o = this.juris.domRenderer.render(a); return o && (this.instances.set(o, i), r?.size > 0 && this.componentStates.set(o, r), i.hooks.onMount && setTimeout((() => { try { const e = i.hooks.onMount(); e?.then && s(e).catch((e => console.error(`Async onMount error in ${t}:`, e))) } catch (e) { console.error(`onMount error in ${t}:`, e) } }), 0)), o } _handleAsyncLifecycleRender(e, t, n) { const r = this._createPlaceholder(`Loading ${t.name}...`, "juris-async-lifecycle"); return e.then((e => { try { const i = this.juris.domRenderer.render(e); i && (this.instances.set(i, t), n?.size > 0 && this.componentStates.set(i, n), r.parentNode && r.parentNode.replaceChild(i, r), t.hooks.onMount && setTimeout((() => { try { const e = t.hooks.onMount(); e?.then && s(e).catch((e => console.error(`Async onMount error in ${t.name}:`, e))) } catch (e) { console.error(`onMount error in ${t.name}:`, e) } }), 0)) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } updateInstance(e, t) { const s = this.instances.get(e); if (!s) return; const r = s.props; n(r, t) || (this._hasAsyncProps(t) ? this._resolveAsyncProps(t).then((t => { s.props = t, this._performUpdate(s, e, r, t) })).catch((e => console.error(`Error updating async props for ${s.name}:`, e))) : (s.props = t, this._performUpdate(s, e, r, t))) } _performUpdate(e, t, n, r) { if (e.hooks.onUpdate) try { const t = e.hooks.onUpdate(n, r); t?.then && s(t).catch((t => console.error(`Async onUpdate error in ${e.name}:`, t))) } catch (t) { console.error(`onUpdate error in ${e.name}:`, t) } try { const n = e.render(), r = s(n); r !== n ? r.then((e => { this.juris.domRenderer.updateElementContent(t, e) })).catch((t => console.error(`Async re-render error in ${e.name}:`, t))) : this.juris.domRenderer.updateElementContent(t, n) } catch (t) { console.error(`Re-render error in ${e.name}:`, t) } } cleanup(e) { const t = this.instances.get(e); if (t?.hooks?.onUnmount) try { const e = t.hooks.onUnmount(); e?.then && s(e).catch((e => console.error(`Async onUnmount error in ${t.name}:`, e))) } catch (e) { console.error(`onUnmount error in ${t.name}:`, e) } const n = this.componentStates.get(e); n && (n.forEach((e => { const t = e.split("."); let n = this.juris.stateManager.state; for (let e = 0; e < t.length - 1; e++) { if (!n[t[e]]) return; n = n[t[e]] } delete n[t[t.length - 1]] })), this.componentStates.delete(e)), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e), this.instances.delete(e) } _createPlaceholder(e, t) { const n = document.createElement("div"); return n.className = t, n.textContent = e, n.style.cssText = "padding: 8px; background: #f0f0f0; border: 1px dashed #ccc; opacity: 0.7;", n } _createErrorElement(e) { const t = document.createElement("div"); return t.style.cssText = "color: red; border: 1px solid red; padding: 8px; background: #ffe6e6;", t.textContent = `Component Error: ${e.message}`, t } _replaceWithError(e, t) { const n = this._createErrorElement(t); e.parentNode && e.parentNode.replaceChild(n, e), this.asyncPlaceholders.delete(e) } clearAsyncPropsCache() { this.asyncPropsCache.clear() } getAsyncStats() { return { activePlaceholders: this.asyncPlaceholders.size, registeredComponents: this.components.size, cachedAsyncProps: this.asyncPropsCache.size } } } class DOMRenderer { constructor(e) { this.juris = e, this.subscriptions = new WeakMap, this.eventMap = { ondoubleclick: "dblclick", onmousedown: "mousedown", onmouseup: "mouseup", onmouseover: "mouseover", onmouseout: "mouseout", onmousemove: "mousemove", onkeydown: "keydown", onkeyup: "keyup", onkeypress: "keypress", onfocus: "focus", onblur: "blur", onchange: "change", oninput: "input", onsubmit: "submit", onload: "load", onresize: "resize", onscroll: "scroll" }, this.elementCache = new Map, this.recyclePool = new Map, this.renderMode = "fine-grained", this.failureCount = 0, this.maxFailures = 3, this.asyncCache = new Map, this.asyncPlaceholders = new WeakMap } setRenderMode(e) { ["fine-grained", "batch"].includes(e) && (this.renderMode = e, console.log(`Juris: Render mode set to '${e}'`)) } getRenderMode() { return this.renderMode } isFineGrained() { return "fine-grained" === this.renderMode } isBatchMode() { return "batch" === this.renderMode } render(e) { if (!e || "object" != typeof e) return null; if (Array.isArray(e)) { const t = document.createDocumentFragment(); return e.forEach((e => { const n = this.render(e); n && t.appendChild(n) })), t } const t = Object.keys(e)[0], n = e[t] || {}; if (this.juris.componentManager.components.has(t)) { const e = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = null; const s = this.juris.componentManager.create(t, n); return this.juris.stateManager.currentTracking = e, s } if ("string" != typeof t || 0 === t.length) return null; if ("fine-grained" === this.renderMode) return this._createElementFineGrained(t, n); try { const e = n.key || this._generateKey(t, n), s = this.elementCache.get(e); return s && this._canReuseElement(s, t, n) ? (this._updateElementProperties(s, n), s) : this._createElementOptimized(t, n, e) } catch (e) { return this.failureCount++, this.failureCount >= this.maxFailures && (this.renderMode = "fine-grained"), this._createElementFineGrained(t, n) } } _createElementFineGrained(e, t) { const n = document.createElement(e), s = [], r = []; return this._hasAsyncProps(t) ? this._setupAsyncElement(n, t, s, r) : this._setupSyncElement(n, t, s, r), (s.length > 0 || r.length > 0) && this.subscriptions.set(n, { subscriptions: s, eventListeners: r }), n } _hasAsyncProps(e) { return Object.entries(e).some((([e, t]) => !e.startsWith("on") && this._isPromiseLike(t))) } _isPromiseLike(e) { return e?.then } _setupAsyncElement(e, t, n, s) { const r = {}, i = {}; Object.entries(t).forEach((([t, n]) => { t.startsWith("on") ? this._handleEvent(e, t, n, s) : this._isPromiseLike(n) ? (i[t] = n, this._setPlaceholder(e, t)) : r[t] = n })), this._setupSyncElement(e, r, n, s), Object.keys(i).length > 0 && this._resolveAsyncProps(e, i, n) } _setupSyncElement(e, t, n, s) { Object.entries(t).forEach((([t, r]) => { "children" === t ? this._handleChildren(e, r, n) : "text" === t ? this._handleText(e, r, n) : "style" === t ? this._handleStyle(e, r, n) : t.startsWith("on") ? this._handleEvent(e, t, r, s) : "function" == typeof r ? this._handleReactiveAttribute(e, t, r, n) : "key" !== t && this._setStaticAttribute(e, t, r) })) } _setPlaceholder(e, t) { ({ text: () => { e.textContent = "...", e.classList.add("juris-async-loading") }, children: () => { const t = document.createElement("span"); t.textContent = "Loading...", t.className = "juris-async-loading", e.appendChild(t) }, className: () => e.classList.add("juris-async-loading"), style: () => { e.style.opacity = "0.7", e.classList.add("juris-async-loading") } }[t] || (() => e.setAttribute(t, "loading")))() } _resolveAsyncProps(e, t, n) { const r = this._generateAsyncCacheKey(t), i = this.asyncCache.get(r); if (i && Date.now() - i.timestamp < 5e3) return void this._applyResolvedProps(e, i.props, n); const a = Object.entries(t).map((([e, t]) => s(t).then((t => ({ key: e, value: t, success: !0 }))).catch((t => ({ key: e, error: t.message, success: !1 }))))); Promise.all(a).then((t => { const s = {}; t.forEach((({ key: e, value: t, error: n, success: r }) => { s[e] = r ? t : { __asyncError: n } })), this.asyncCache.set(r, { props: s, timestamp: Date.now() }), this._applyResolvedProps(e, s, n) })) } _applyResolvedProps(e, t, n) { e.classList.remove("juris-async-loading"), Object.entries(t).forEach((([t, s]) => { if (s?.__asyncError) return console.error(`Async prop '${t}' failed:`, s.__asyncError), void this._setErrorState(e, t, s.__asyncError); "children" === t ? this._handleAsyncChildren(e, s, n) : "text" === t ? e.textContent = s : "style" === t ? Object.assign(e.style, "object" == typeof s ? s : {}) : "innerHTML" === t ? e.innerHTML = s : this._setStaticAttribute(e, t, s) })) } _setErrorState(e, t, n) { e.classList.add("juris-async-error"), "text" === t ? e.textContent = `Error: ${n}` : "children" === t && (e.innerHTML = `<span class="juris-async-error">Error: ${n}</span>`) } _handleAsyncChildren(e, t, n) { if (e.innerHTML = "", Array.isArray(t)) t.forEach((t => { const n = this.render(t); n && e.appendChild(n) })); else if (t) { const n = this.render(t); n && e.appendChild(n) } } _generateAsyncCacheKey(e) { return JSON.stringify(e, ((e, t) => this._isPromiseLike(t) ? "[Promise]" : t)) } _handleChildren(e, t, n) { "fine-grained" === this.renderMode ? this._handleChildrenFineGrained(e, t, n) : this._handleChildrenOptimized(e, t, n) } _handleChildrenFineGrained(e, t, n) { "function" == typeof t ? this._handleReactiveChildren(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncChildrenDirect(e, t) : this._updateChildren(e, t) } _handleChildrenOptimized(e, t, n) { if ("function" == typeof t) { let r = null, i = [], a = !0; const o = () => { try { const n = t(); if (this._isPromiseLike(n)) s(n).then((t => { if ("ignore" !== t && !this._childrenEqual(r, t)) if (a) try { i = this._reconcileChildren(e, i, t), r = t } catch (n) { console.warn("Reconciliation failed, falling back to safe rendering:", n.message), a = !1, this._updateChildren(e, t), r = t } else this._updateChildren(e, t), r = t })).catch((e => { console.error("Error in async children function:", e), a = !1 })); else if ("ignore" !== n && !this._childrenEqual(r, n)) if (a) try { i = this._reconcileChildren(e, i, n), r = n } catch (t) { console.warn("Reconciliation failed, falling back to safe rendering:", t.message), a = !1, this._updateChildren(e, n), r = n } else this._updateChildren(e, n), r = n } catch (t) { console.error("Error in children function:", t), a = !1; try { this._updateChildren(e, []) } catch (e) { console.error("Even safe fallback failed:", e) } } }; this._createReactiveUpdate(e, o, n); try { const n = t(); this._isPromiseLike(n) ? s(n).then((t => { i = this._reconcileChildren(e, [], t), r = t })).catch((t => { console.warn("Initial async children failed, using safe method:", t.message), a = !1, this._updateChildren(e, []) })) : (i = this._reconcileChildren(e, [], n), r = n) } catch (n) { console.warn("Initial reconciliation failed, using safe method:", n.message), a = !1; const s = t(); this._updateChildren(e, s), r = s } } else if (this._isPromiseLike(t)) this._handleAsyncChildrenDirect(e, t); else try { this._reconcileChildren(e, [], t) } catch (n) { console.warn("Static reconciliation failed, using safe method:", n.message), this._updateChildren(e, t) } } _childrenEqual(e, t) { return n && n(e, t) } _reconcileChildren(e, t, n) { Array.isArray(n) || (n = n ? [n] : []); const s = [], r = document.createDocumentFragment(), i = new Map; t.forEach(((e, t) => { const n = e._jurisKey || `auto-${t}`; i.set(n, e) })); const a = new Set; n.forEach(((t, n) => { if (!t || "object" != typeof t) return; const o = Object.keys(t)[0], c = t[o] || {}, h = c.key || this._generateKey(o, c, n), l = i.get(h); if (l && !a.has(l) && this._canReuseElement(l, o, c) && !this._wouldCreateCircularReference(e, l)) l.parentNode && l.parentNode.removeChild(l), this._updateElementProperties(l, c), s.push(l), r.appendChild(l), a.add(l), i.delete(h); else { const n = this.render(t); n && !this._wouldCreateCircularReference(e, n) && (n._jurisKey = h, s.push(n), r.appendChild(n)) } })), i.forEach((e => { a.has(e) || this._recycleElement(e) })); try { e.textContent = "", r.hasChildNodes() && e.appendChild(r) } catch (t) { console.error("Error in reconcileChildren:", t), e.textContent = "", s.forEach((t => { try { t && !this._wouldCreateCircularReference(e, t) && e.appendChild(t) } catch (e) { console.warn("Failed to append child, skipping:", e) } })) } return s } _wouldCreateCircularReference(e, t) { if (!e || !t) return !1; if (e === t) return !0; try { let n = e.parentNode; for (; n;) { if (n === t) return !0; n = n.parentNode } if (t.contains && t.contains(e)) return !0; if (t.children) for (let n of t.children) if (this._wouldCreateCircularReference(e, n)) return !0 } catch (e) { return console.warn("Error checking circular reference, assuming unsafe:", e), !0 } return !1 } _recycleElement(e) { if (!e || !e.tagName) return; const t = e.tagName.toLowerCase(); e.parentNode && e.parentNode.removeChild(e), this.recyclePool.has(t) || this.recyclePool.set(t, []); const n = this.recyclePool.get(t); n.length < 100 && (this.cleanup(e), this._resetElement(e), n.push(e)) } _handleAsyncChildrenDirect(e, t) { const n = document.createElement("div"); n.className = "juris-async-loading", n.textContent = "Loading content...", e.appendChild(n), this.asyncPlaceholders.set(e, { type: "children", placeholder: n }), s(t).then((t => { n.parentNode && e.removeChild(n), this._updateChildren(e, t), this.asyncPlaceholders.delete(e) })).catch((e => { console.error("Async children failed:", e), n.textContent = `Error loading content: ${e.message}`, n.className = "juris-async-error" })) } _handleReactiveChildren(e, t, r) { let i = null, a = !1; this._createReactiveUpdate(e, (() => { try { const r = t(); this._isPromiseLike(r) ? s(r).then((t => { "ignore" === t || a && n(t, i) || (this._updateChildren(e, t), i = t, a = !0) })).catch((e => console.error("Error in async reactive children:", e))) : "ignore" === r || a && n(r, i) || (this._updateChildren(e, r), i = r, a = !0) } catch (e) { console.error("Error in reactive children function:", e) } }), r) } _updateChildren(e, t) { if ("ignore" === t) return; Array.from(e.children).forEach((e => this.cleanup(e))), e.textContent = ""; const n = document.createDocumentFragment(); if (Array.isArray(t)) t.forEach((e => { const t = this.render(e); t && n.appendChild(t) })); else if (t) { const e = this.render(t); e && n.appendChild(e) } n.hasChildNodes() && e.appendChild(n) } _handleText(e, t, n) { "function" == typeof t ? this._handleReactiveText(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncTextDirect(e, t) : e.textContent = t } _handleAsyncTextDirect(e, t) { e.textContent = "Loading...", e.classList.add("juris-async-loading"), s(t).then((t => { e.textContent = t, e.classList.remove("juris-async-loading") })).catch((t => { console.error("Async text failed:", t), e.textContent = `Error: ${t.message}`, e.classList.add("juris-async-error") })) } _handleReactiveText(e, t, n) { let r = null, i = !1; this._createReactiveUpdate(e, (() => { try { const n = t(); this._isPromiseLike(n) ? s(n).then((t => { i && t === r || (e.textContent = t, r = t, i = !0) })).catch((e => console.error("Error in async reactive text:", e))) : i && n === r || (e.textContent = n, r = n, i = !0) } catch (e) { console.error("Error in reactive text function:", e) } }), n) } _handleStyle(e, t, n) { "function" == typeof t ? this._handleReactiveStyle(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncStyleDirect(e, t) : "object" == typeof t && Object.assign(e.style, t) } _handleAsyncStyleDirect(e, t) { e.style.opacity = "0.7", e.classList.add("juris-async-loading"), s(t).then((t => { e.style.opacity = "", e.classList.remove("juris-async-loading"), "object" == typeof t && Object.assign(e.style, t) })).catch((e => console.error("Async style failed:", e))) } _handleReactiveStyle(e, t, r) { let i = null, a = !1; this._createReactiveUpdate(e, (() => { try { const r = t(); this._isPromiseLike(r) ? s(r).then((t => { a && n(t, i) || "object" == typeof t && (Object.assign(e.style, t), i = { ...t }, a = !0) })).catch((e => console.error("Error in async reactive style:", e))) : a && n(r, i) || "object" == typeof r && (Object.assign(e.style, r), i = { ...r }, a = !0) } catch (e) { console.error("Error in reactive style function:", e) } }), r) } _createElementOptimized(e, t, n) { let s = this._getRecycledElement(e); s || (s = document.createElement(e)), n && (this.elementCache.set(n, s), s._jurisKey = n); const r = [], i = []; return this._processProperties(s, t, r, i), (r.length > 0 || i.length > 0) && this.subscriptions.set(s, { subscriptions: r, eventListeners: i }), s } _processProperties(e, t, n, s) { Object.keys(t).forEach((r => { const i = t[r]; "children" === r ? this._handleChildren(e, i, n) : "text" === r ? this._handleText(e, i, n) : "innerHTML" === r ? "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : e.innerHTML = i : "style" === r ? this._handleStyle(e, i, n) : r.startsWith("on") ? this._handleEvent(e, r, i, s) : "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : "key" !== r && this._setStaticAttribute(e, r, i) })) } _handleEvent(e, t, n, s) { if ("onclick" === t) { e.style.touchAction = "manipulation", e.style.webkitTapHighlightColor = "transparent", e.style.webkitTouchCallout = "none", e.addEventListener("click", n), s.push({ eventName: "click", handler: n }); let t = 0, r = !1, i = 0, a = 0; const o = e => { t = Date.now(), r = !1, e.touches?.[0] && (i = e.touches[0].clientX, a = e.touches[0].clientY) }, c = e => { if (e.touches?.[0]) { const t = Math.abs(e.touches[0].clientX - i), n = Math.abs(e.touches[0].clientY - a); (t > 10 || n > 10) && (r = !0) } }, h = e => { const s = Date.now() - t; !r && s < 300 && (e.preventDefault(), e.stopPropagation(), n(e)) }; e.addEventListener("touchstart", o, { passive: !0 }), e.addEventListener("touchmove", c, { passive: !0 }), e.addEventListener("touchend", h, { passive: !1 }), s.push({ eventName: "touchstart", handler: o }, { eventName: "touchmove", handler: c }, { eventName: "touchend", handler: h }) } else { const r = this.eventMap[t.toLowerCase()] || t.slice(2).toLowerCase(); e.addEventListener(r, n), s.push({ eventName: r, handler: n }) } } _handleReactiveAttribute(e, t, r, i) { let a = null, o = !1; this._createReactiveUpdate(e, (() => { try { const i = r(); this._isPromiseLike(i) ? s(i).then((s => { o && n(s, a) || (this._setStaticAttribute(e, t, s), a = s, o = !0) })).catch((e => console.error(`Error in async reactive attribute '${t}':`, e))) : o && n(i, a) || (this._setStaticAttribute(e, t, i), a = i, o = !0) } catch (e) { console.error(`Error in reactive attribute '${t}':`, e) } }), i) } _setStaticAttribute(e, t, n) { if (!["children", "key"].includes(t)) { if ("function" == typeof n) return "value" === t && ["INPUT", "TEXTAREA", "SELECT"].includes(e.tagName) ? void (e.value = n()) : void console.warn(`Function value for attribute '${t}' should be handled reactively`); if ("className" === t) e.className = n; else if ("htmlFor" === t) e.setAttribute("for", n); else if ("tabIndex" === t) e.tabIndex = n; else if (t.startsWith("data-") || t.startsWith("aria-")) e.setAttribute(t, n); else if (t in e && "function" != typeof e[t]) try { const s = Object.getOwnPropertyDescriptor(e, t) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), t); s && !1 === s.writable ? e.setAttribute(t, n) : e[t] = n } catch (s) { e.setAttribute(t, n) } else e.setAttribute(t, n) } } _createReactiveUpdate(e, t, n) { const s = this.juris.stateManager.startTracking(), r = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = s; try { t() } catch (e) { console.error("Error capturing dependencies:", e) } finally { this.juris.stateManager.currentTracking = r } s.forEach((e => { const s = this.juris.stateManager.subscribeInternal(e, t); n.push(s) })) } updateElementContent(e, t) { this._updateChildren(e, [t]) } cleanup(e) { this.juris.componentManager.cleanup(e); const t = this.subscriptions.get(e); t && (t.subscriptions?.forEach((e => { try { e() } catch (e) { console.warn("Error during subscription cleanup:", e) } })), t.eventListeners?.forEach((({ eventName: t, handler: n }) => { try { e.removeEventListener(t, n) } catch (e) { console.warn("Error during event listener cleanup:", e) } })), this.subscriptions.delete(e)), e._jurisKey && this.elementCache.delete(e._jurisKey), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e); try { Array.from(e.children || []).forEach((e => { try { this.cleanup(e) } catch (e) { console.warn("Error cleaning up child element:", e) } })) } catch (e) { console.warn("Error during children cleanup:", e) } } _generateKey(e, t) { if (t.key) return t.key; const n = [e];["id", "className", "text"].forEach((e => { t[e] && "function" != typeof t[e] && n.push(`${e}:${t[e]}`) })); const s = this._hashProps(t); return n.push(`hash:${s}`), n.join("|") } _hashProps(e) { const t = JSON.stringify(e, ((e, t) => "function" == typeof t ? "[function]" : t)); let n = 0; for (let e = 0; e < t.length; e++) { n = (n << 5) - n + t.charCodeAt(e), n &= n } return Math.abs(n).toString(36) } _getRecycledElement(e) { const t = this.recyclePool.get(e); if (t?.length > 0) { const e = t.pop(); return this._resetElement(e), e } return null } _resetElement(e) { e.textContent = "", e.className = "", e.removeAttribute("style"); const t = ["id", "data-juris-key"]; Array.from(e.attributes).forEach((n => { t.includes(n.name) || e.removeAttribute(n.name) })) } _canReuseElement(e, t, n) { return e.tagName.toLowerCase() === t.toLowerCase() } _updateElementProperties(e, t) { Object.keys(t).forEach((n => { if (!["key", "children", "text", "style"].includes(n)) { const s = t[n]; "function" != typeof s && this._setStaticAttribute(e, n, s) } })) } clearAsyncCache() { this.asyncCache.clear() } getAsyncStats() { return { cachedAsyncProps: this.asyncCache.size, activePlaceholders: this.asyncPlaceholders.size } } } class DOMEnhancer { constructor(e) { this.juris = e, this.observers = new Map, this.enhancedElements = new WeakSet, this.enhancementRules = new Map, this.containerEnhancements = new WeakMap, this.options = { debounceMs: 5, batchUpdates: !0, observeSubtree: !0, observeChildList: !0 }, this.pendingEnhancements = new Set, this.enhancementTimer = null } enhance(e, t, n = {}) { const s = { ...this.options, ...n }; return this._hasSelectorsCategory(t) ? this._enhanceWithSelectors(e, t, s) : (this.enhancementRules.set(e, { definition: t, config: s, type: "simple" }), this._enhanceExistingElements(e, t, s), !1 !== s.observeNewElements && this._setupMutationObserver(e, t, s), () => this._unenhance(e)) } _hasSelectorsCategory(e) { if (e?.selectors) return !0; if ("function" == typeof e) try { const t = e(this.juris.createContext()); return t?.selectors } catch (e) { return !1 } return !1 } _enhanceWithSelectors(e, t, n) { return this.enhancementRules.set(e, { definition: t, config: n, type: "selectors" }), this._enhanceExistingContainers(e, t, n), !1 !== n.observeNewElements && this._setupSelectorsObserver(e, t, n), () => this._unenhanceSelectors(e) } _enhanceExistingContainers(e, t, n) { document.querySelectorAll(e).forEach((e => this._enhanceContainer(e, t, n))) } _enhanceContainer(e, t, n) { if (!this.enhancedElements.has(e)) try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-container", Date.now()); let s = t; if ("function" == typeof t) { s = t(this.juris.createContext(e)) } if (!s?.selectors) return void console.warn('Selectors enhancement must have a "selectors" property'); const r = new Map; this.containerEnhancements.set(e, r), this._applyContainerProperties(e, s), Object.entries(s.selectors).forEach((([t, s]) => { this._enhanceSelector(e, t, s, r, n) })) } catch (t) { console.error("Error enhancing container:", t), this.enhancedElements.delete(e) } } _applyContainerProperties(e, t) { const n = { ...t }; delete n.selectors, Object.keys(n).length > 0 && this._applyEnhancements(e, n) } _enhanceSelector(e, t, n, s, r) { const i = e.querySelectorAll(t), a = new Set; i.forEach((s => { this.enhancedElements.has(s) || (this._enhanceSelectorElement(s, n, e, t), a.add(s)) })), s.set(t, { definition: n, enhancedElements: a }) } _enhanceSelectorElement(e, t, n, s) { try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-selector", Date.now()); let n = t; if ("function" == typeof t) { if (n = t(this.juris.createContext(e)), !n || "object" != typeof n) return console.warn(`Selector '${s}' function must return a definition object`), void this.enhancedElements.delete(e) } const r = this._processElementAwareFunctions(e, n); this._applyEnhancements(e, r) } catch (t) { console.error("Error enhancing selector element:", t), this.enhancedElements.delete(e) } } _processElementAwareFunctions(e, t) { const n = {}; return Object.entries(t).forEach((([t, s]) => { if ("function" == typeof s) if (t.startsWith("on")) n[t] = s; else if (s.length > 0) try { const r = s(this.juris.createContext(e)); n[t] = r && "object" == typeof r ? r : s } catch (e) { console.warn(`Error processing element-aware function '${t}':`, e), n[t] = s } else n[t] = s; else n[t] = s })), n } _setupSelectorsObserver(e, t, n) { const s = `selectors_${e}`; if (this.observers.has(s)) return; const r = new MutationObserver((s => { n.debounceMs > 0 ? this._debouncedProcessSelectorsMutations(s, e, t, n) : this._processSelectorsMutations(s, e, t, n) })); r.observe(document.body, { childList: n.observeChildList, subtree: n.observeSubtree }), this.observers.set(s, r) } _processSelectorsMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this._handleNewNodeForSelectors(e, t, n, s) })) })) } _handleNewNodeForSelectors(e, t, n, s) { e.matches?.(t) && this._enhanceContainer(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceContainer(e, n, s) })), this._enhanceNewElementsInContainers(e) } _enhanceNewElementsInContainers(e) { document.querySelectorAll("[data-juris-enhanced-container]").forEach((t => { if (!t.contains(e)) return; const n = this.containerEnhancements.get(t); n && n.forEach(((n, s) => { const { definition: r, enhancedElements: i } = n; e.matches?.(s) && (this._enhanceSelectorElement(e, r, t, s), i.add(e)), e.querySelectorAll && e.querySelectorAll(s).forEach((e => { this.enhancedElements.has(e) || (this._enhanceSelectorElement(e, r, t, s), i.add(e)) })) })) })) } _debouncedProcessSelectorsMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this.pendingEnhancements.add({ node: e, containerSelector: t, definition: n, config: s, type: "selectors", timestamp: Date.now() }) })) })), this.enhancementTimer && clearTimeout(this.enhancementTimer), this.enhancementTimer = setTimeout((() => { this._processPendingEnhancements(), this.enhancementTimer = null }), s.debounceMs) } _unenhanceSelectors(e) { const t = `selectors_${e}`, n = this.observers.get(t); n && (n.disconnect(), this.observers.delete(t)), this.enhancementRules.delete(e), document.querySelectorAll(`${e}[data-juris-enhanced-container]`).forEach((e => { this._cleanupContainer(e) })) } _cleanupContainer(e) { const t = this.containerEnhancements.get(e); t && (t.forEach((e => { e.enhancedElements.forEach((e => this._cleanupElement(e))) })), this.containerEnhancements.delete(e)), this._cleanupElement(e), e.removeAttribute("data-juris-enhanced-container") } _enhanceExistingElements(e, t, n) { const s = document.querySelectorAll(e); n.batchUpdates && s.length > 1 ? this._batchEnhanceElements(Array.from(s), t, n) : s.forEach((e => this._enhanceElement(e, t, n))) } _batchEnhanceElements(e, t, n) { e.filter((e => !this.enhancedElements.has(e))).forEach((e => this._enhanceElement(e, t, n))) } _enhanceElement(e, t, n) { if (!this.enhancedElements.has(e)) try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced", Date.now()); let s = t; if ("function" == typeof t) { if (s = t(this.juris.createContext(e)), !s || "object" != typeof s) return console.warn("Enhancement function must return a definition object"), void this.enhancedElements.delete(e) } this._applyEnhancements(e, s), n.onEnhanced?.(e, this.juris.createContext(e)) } catch (t) { console.error("Error enhancing element:", t), this.enhancedElements.delete(e) } } _applyEnhancements(e, t) { const n = [], s = [], r = this.juris.domRenderer; Object.keys(t).forEach((i => { const a = t[i]; try { "children" === i ? this._handleChildren(e, a, n, r) : "text" === i ? r._handleText(e, a, n) : "innerHTML" === i ? this._handleInnerHTML(e, a, n, r) : "style" === i ? r._handleStyle(e, a, n) : i.startsWith("on") ? r._handleEvent(e, i, a, s) : "function" == typeof a ? r._handleReactiveAttribute(e, i, a, n) : r._setStaticAttribute(e, i, a) } catch (e) { console.error(`Error processing enhancement property '${i}':`, e) } })), (n.length > 0 || s.length > 0) && this.juris.domRenderer.subscriptions.set(e, { subscriptions: n, eventListeners: s }) } _handleChildren(e, t, n, s) { s.isFineGrained() ? s._handleChildrenFineGrained(e, t, n) : s._handleChildrenOptimized(e, t, n) } _handleInnerHTML(e, t, n, s) { "function" == typeof t ? s._handleReactiveAttribute(e, "innerHTML", t, n) : e.innerHTML = t } _setupMutationObserver(e, t, n) { if (this.observers.has(e)) return; const s = new MutationObserver((s => { n.debounceMs > 0 ? this._debouncedProcessMutations(s, e, t, n) : this._processMutations(s, e, t, n) })); s.observe(document.body, { childList: n.observeChildList, subtree: n.observeSubtree }), this.observers.set(e, s) } _processMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this._enhanceNewNode(e, t, n, s) })) })) } _enhanceNewNode(e, t, n, s) { e.matches?.(t) && this._enhanceElement(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceElement(e, n, s) })) } _debouncedProcessMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this.pendingEnhancements.add({ node: e, selector: t, definition: n, config: s, timestamp: Date.now() }) })) })), this.enhancementTimer && clearTimeout(this.enhancementTimer), this.enhancementTimer = setTimeout((() => { this._processPendingEnhancements(), this.enhancementTimer = null }), s.debounceMs) } _processPendingEnhancements() { const e = Array.from(this.pendingEnhancements); this.pendingEnhancements.clear(), e.forEach((({ node: e, selector: t, definition: n, config: s, containerSelector: r, type: i }) => { try { "selectors" === i ? this._handleNewNodeForSelectors(e, r, n, s) : this._enhanceNewNode(e, t, n, s) } catch (e) { console.error("Error processing pending enhancement:", e) } })) } _unenhance(e) { const t = this.observers.get(e); t && (t.disconnect(), this.observers.delete(e)), this.enhancementRules.delete(e), document.querySelectorAll(`${e}[data-juris-enhanced]`).forEach((e => { this._cleanupElement(e) })) } _cleanupElement(e) { this.juris.domRenderer.cleanup(e), this.enhancedElements.delete(e), e.removeAttribute("data-juris-enhanced"), e.removeAttribute("data-juris-enhanced-selector") } configure(e) { Object.assign(this.options, e) } getStats() { const e = document.querySelectorAll("[data-juris-enhanced]").length, t = document.querySelectorAll("[data-juris-enhanced-container]").length, n = document.querySelectorAll("[data-juris-enhanced-selector]").length; return { enhancementRules: this.enhancementRules.size, activeObservers: this.observers.size, pendingEnhancements: this.pendingEnhancements.size, enhancedElements: e, enhancedContainers: t, enhancedSelectors: n, totalEnhanced: e + n } } destroy() { this.observers.forEach((e => e.disconnect())), this.observers.clear(), this.enhancementRules.clear(), this.enhancementTimer && (clearTimeout(this.enhancementTimer), this.enhancementTimer = null), document.querySelectorAll("[data-juris-enhanced], [data-juris-enhanced-selector]").forEach((e => { this._cleanupElement(e) })), document.querySelectorAll("[data-juris-enhanced-container]").forEach((e => { this._cleanupContainer(e) })), this.pendingEnhancements.clear() } } class Juris { constructor(e = {}) { this.services = e.services || {}, this.layout = e.layout, this.stateManager = new StateManager(e.states || {}, e.middleware || []), this.headlessManager = new HeadlessManager(this), this.componentManager = new ComponentManager(this), this.domRenderer = new DOMRenderer(this), this.domEnhancer = new DOMEnhancer(this), e.headlessComponents && Object.entries(e.headlessComponents).forEach((([e, t]) => { "function" == typeof t ? this.headlessManager.register(e, t) : this.headlessManager.register(e, t.fn, t.options) })), this.headlessManager.initializeQueued(), "fine-grained" === e.renderMode ? this.domRenderer.setRenderMode("fine-grained") : "batch" === e.renderMode && this.domRenderer.setRenderMode("batch"), !0 === e.legacyMode && (console.warn('legacyMode is deprecated. Use renderMode: "fine-grained" instead.'), this.domRenderer.setRenderMode("fine-grained")), e.components && Object.entries(e.components).forEach((([e, t]) => { this.componentManager.register(e, t) })) } init() { } createHeadlessContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, headless: this.headlessManager.context, ...this.headlessAPIs || {}, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t) }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), getHeadlessStatus: () => this.headlessManager.getStatus() }, juris: this }; return e && (t.element = e), t } createContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, ...this.headlessAPIs || {}, headless: this.headlessManager.context, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t), getHeadlessAPI: e => this.headlessManager.getAPI(e), getAllHeadlessAPIs: () => this.headlessManager.getAllAPIs() }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), setRenderMode: e => this.setRenderMode(e), getRenderMode: () => this.getRenderMode(), isFineGrained: () => this.isFineGrained(), isBatchMode: () => this.isBatchMode(), getHeadlessStatus: () => this.headlessManager.getStatus() }, juris: this }; return e && (t.element = e), t } getState(e, t, n) { return this.stateManager.getState(e, t, n) } setState(e, t, n) { return this.stateManager.setState(e, t, n) } subscribe(e, t, n = !0) { return this.stateManager.subscribe(e, t, n) } subscribeExact(e, t) { return this.stateManager.subscribeExact(e, t) } registerComponent(e, t) { return this.componentManager.register(e, t) } registerHeadlessComponent(e, t, n) { return this.headlessManager.register(e, t, n) } getComponent(e) { return this.componentManager.components.get(e) } getHeadlessComponent(e) { return this.headlessManager.getInstance(e) } initializeHeadlessComponent(e, t) { return this.headlessManager.initialize(e, t) } setRenderMode(e) { this.domRenderer.setRenderMode(e) } getRenderMode() { return this.domRenderer.getRenderMode() } isFineGrained() { return this.domRenderer.isFineGrained() } isBatchMode() { return this.domRenderer.isBatchMode() } enableLegacyMode() { console.warn('enableLegacyMode() is deprecated. Use setRenderMode("fine-grained") instead.'), this.setRenderMode("fine-grained") } disableLegacyMode() { console.warn('disableLegacyMode() is deprecated. Use setRenderMode("batch") instead.'), this.setRenderMode("batch") } _updateComponentContexts() { this.headlessAPIs } registerAndInitHeadless(e, t, n = {}) { return this.headlessManager.register(e, t, n), this.headlessManager.initialize(e, n) } getHeadlessStatus() { return this.headlessManager.getStatus() } objectToHtml(e) { return this.domRenderer.render(e) } render(e = "#app") { const t = "string" == typeof e ? document.querySelector(e) : e; if (!t) return; return this.getState("isHydration", !1) ? this._renderWithHydration(t) : this._renderImmediate(t) } _renderImmediate = function (e) { e.innerHTML = ""; const t = this.domRenderer.render(this.layout); t && e.appendChild(t) }; _renderWithHydration = async function (e) { const t = document.createElement("div"); t.style.cssText = "position: absolute; left: -9999px; visibility: hidden;", document.body.appendChild(t); try { r(); const n = this.domRenderer.render(this.layout); for (n && t.appendChild(n), await a(), e.innerHTML = ""; t.firstChild;)e.appendChild(t.firstChild); this.headlessManager.initializeQueued() } finally { i(), document.body.removeChild(t) } }; _renderError(e, t) { const n = document.createElement("div"); n.style.cssText = "color: red; border: 2px solid red; padding: 16px; margin: 8px; background: #ffe6e6;", n.innerHTML = `\n                <h3>Render Error</h3>\n                <p><strong>Message:</strong> ${t.message}</p>\n                <pre style="background: #f5f5f5; padding: 8px; overflow: auto;">${t.stack || ""}</pre>\n            `, e.appendChild(n) } enhance(e, t, n) { return this.domEnhancer.enhance(e, t, n) } configureEnhancement(e) { return this.domEnhancer.configure(e) } getEnhancementStats() { return this.domEnhancer.getStats() } cleanup() { this.headlessManager.cleanup() } destroy() { this.cleanup(), this.domEnhancer.destroy(), this.stateManager.subscribers.clear(), this.stateManager.externalSubscribers.clear(), this.componentManager.components.clear(), this.headlessManager.components.clear() } } "undefined" != typeof window && (window.Juris = Juris, window.deepEquals = n), "undefined" != typeof module && module.exports && (module.exports = Juris, module.exports.deepEquals = n) }();