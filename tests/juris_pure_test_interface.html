<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juris Test Interface - Pure Juris Implementation</title>
    <script src="../src/juris.js"></script>
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        /* Override Prism.js theme for better dark mode */
        .prism-code {
            background: #1a1a1a !important;
            color: #e0e0e0 !important;
        }
        
        /* Custom status and result styles */
        .status-pass { color: #4CAF50; font-weight: bold; }
        .status-fail { color: #f44336; font-weight: bold; }
        .status-pending { color: #FF9800; font-weight: bold; }
        .status-running { color: #2196F3; font-weight: bold; }
        
        /* Selected test item highlighting */
        .test-item-selected {
            background: #2d2d2d !important;
            border-left: 4px solid #667eea !important;
        }
        
        .test-item:hover {
            background: #252525 !important;
        }
        
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background: #2d2d2d;
            border-left: 4px solid #666;
        }
        
        .test-result.pass { border-left-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .test-result.fail { border-left-color: #f44336; background: rgba(244, 67, 54, 0.1); }
        .test-result.pending { border-left-color: #FF9800; background: rgba(255, 152, 0, 0.1); }
        
        .assertion {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .assertion.pass {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .assertion.fail {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .error-stack {
            background: #2a1a1a;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        // Test Framework Implementation
        class JurisTestFramework {
            constructor() {
                this.tests = new Map();
                this.results = new Map();
                this.currentTest = null;
                this.assertions = [];
            }

            expect(actual) {
                return {
                    toBe: (expected) => this.assert(actual === expected, `Expected ${actual} to be ${expected}`),
                    toEqual: (expected) => this.assert(JSON.stringify(actual) === JSON.stringify(expected), `Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`),
                    toBeTruthy: () => this.assert(!!actual, `Expected ${actual} to be truthy`),
                    toBeFalsy: () => this.assert(!actual, `Expected ${actual} to be falsy`),
                    toContain: (item) => this.assert(actual.includes && actual.includes(item), `Expected ${actual} to contain ${item}`),
                    toBeInstanceOf: (constructor) => this.assert(actual instanceof constructor, `Expected ${actual} to be instance of ${constructor.name}`),
                    toHaveProperty: (property) => this.assert(actual.hasOwnProperty(property), `Expected ${actual} to have property ${property}`),
                    toBeLessThan: (expected) => this.assert(actual < expected, `Expected ${actual} to be less than ${expected}`),
                    toBeGreaterThan: (expected) => this.assert(actual > expected, `Expected ${actual} to be greater than ${expected}`),
                    toBeLessThanOrEqual: (expected) => this.assert(actual <= expected, `Expected ${actual} to be less than or equal to ${expected}`),
                    toBeGreaterThanOrEqual: (expected) => this.assert(actual >= expected, `Expected ${actual} to be greater than or equal to ${expected}`),
                    toBeNull: () => this.assert(actual === null, `Expected ${actual} to be null`),
                    toBeUndefined: () => this.assert(actual === undefined, `Expected ${actual} to be undefined`),
                    toBeDefined: () => this.assert(actual !== undefined, `Expected ${actual} to be defined`),
                    toHaveLength: (length) => this.assert(actual.length === length, `Expected ${actual} to have length ${length}, but got ${actual.length}`),
                    toMatch: (regex) => this.assert(regex.test(actual), `Expected ${actual} to match ${regex}`),
                    toThrow: () => {
                        let threw = false;
                        try {
                            actual();
                        } catch (e) {
                            threw = true;
                        }
                        this.assert(threw, `Expected function to throw`);
                    }
                };
            }

            assert(condition, message) {
                const assertion = { condition, message, passed: condition };
                this.assertions.push(assertion);
                
                if (!condition) {
                    throw new Error(message);
                }
                
                return condition;
            }

            async runTest(testName) {
                const test = this.tests.get(testName);
                if (!test) return;

                this.currentTest = testName;
                this.assertions = [];
                
                const startTime = performance.now();
                let result = {
                    name: testName,
                    status: 'running',
                    duration: 0,
                    assertions: [],
                    error: null
                };

                try {
                    await test.fn();
                    result.status = 'pass';
                    result.assertions = [...this.assertions];
                } catch (error) {
                    result.status = 'fail';
                    result.error = error;
                    result.assertions = [...this.assertions];
                }

                result.duration = performance.now() - startTime;
                this.results.set(testName, result);
                this.currentTest = null;
                
                return result;
            }

            addTest(name, category, fn, code) {
                this.tests.set(name, { name, category, fn, code });
            }

            getTestsByCategory() {
                const categories = {};
                for (const [name, test] of this.tests) {
                    if (!categories[test.category]) {
                        categories[test.category] = [];
                    }
                    categories[test.category].push({ name, ...test });
                }
                return categories;
            }
        }

        // Initialize test framework
        const testFramework = new JurisTestFramework();

        // Enhanced syntax highlighting using Prism.js
        function highlightCode(code) {
            if (typeof Prism !== 'undefined') {
                return Prism.highlight(code, Prism.languages.javascript, 'javascript');
            }
            // Fallback if Prism isn't loaded
            return code;
        }

        // Define comprehensive test suite
        // Define comprehensive test suite
function defineTests() {
    // State Management Tests
    testFramework.addTest('Basic State Operations', 'State Management', async function() {
        const juris = new Juris();
        
        juris.setState('user.name', 'John');
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('user.name')).toBe('John');
        
        juris.setState('user.age', 30);
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('user.age')).toBe(30);
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('nonexistent', 'default')).toBe('default');
    }, `const juris = new Juris();

juris.setState('user.name', 'John');
testFramework.expect(juris.getState('user.name')).toBe('John');

juris.setState('user.age', 30);
testFramework.expect(juris.getState('user.age')).toBe(30);

testFramework.expect(juris.getState('nonexistent', 'default')).toBe('default');`);

    testFramework.addTest('State Reactivity', 'State Management', async function() {
        const juris = new Juris();
        let callCount = 0;
        let lastValue = null;
        
        const unsubscribe = juris.subscribe('counter', (value) => {
            callCount++;
            lastValue = value;
        });
        
        juris.setState('counter', 1);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(callCount).toBe(1);
        testFramework.expect(lastValue).toBe(1);
        
        juris.setState('counter', 2);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(callCount).toBe(2);
        testFramework.expect(lastValue).toBe(2);
        
        unsubscribe();
    }, `const juris = new Juris();
let callCount = 0;
let lastValue = null;

const unsubscribe = juris.subscribe('counter', (value) => {
    callCount++;
    lastValue = value;
});

juris.setState('counter', 1);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(callCount).toBe(1);
testFramework.expect(lastValue).toBe(1);

juris.setState('counter', 2);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(callCount).toBe(2);
testFramework.expect(lastValue).toBe(2);

unsubscribe();`);

    testFramework.addTest('Deep State Paths', 'State Management', async function() {
        const juris = new Juris();
        
        juris.setState('app.user.profile.settings.theme', 'dark');
        juris.setState('app.user.profile.settings.language', 'en');
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('app.user.profile.settings.theme')).toBe('dark');
        testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('theme');
        testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('language');
    }, `const juris = new Juris();

juris.setState('app.user.profile.settings.theme', 'dark');
juris.setState('app.user.profile.settings.language', 'en');

testFramework.expect(juris.getState('app.user.profile.settings.theme')).toBe('dark');
testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('theme');
testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('language');`);

    testFramework.addTest('Array State Operations', 'State Management', async function() {
        const juris = new Juris();
        
        juris.setState('todos', []);
        juris.setState('todos', [{ id: 1, text: 'Learn Juris', done: false }]);
        
        await new Promise(resolve => setTimeout(resolve, 10));
        const todos = juris.getState('todos');
        testFramework.expect(Array.isArray(todos)).toBeTruthy();
        testFramework.expect(todos.length).toBe(1);
        testFramework.expect(todos[0].text).toBe('Learn Juris');
    }, `const juris = new Juris();

juris.setState('todos', []);
juris.setState('todos', [{ id: 1, text: 'Learn Juris', done: false }]);

const todos = juris.getState('todos');
testFramework.expect(Array.isArray(todos)).toBeTruthy();
testFramework.expect(todos.length).toBe(1);
testFramework.expect(todos[0].text).toBe('Learn Juris');`);

    testFramework.addTest('Multiple State Subscribers', 'State Management', async function() {
        const juris = new Juris();
        let subscriber1Called = 0;
        let subscriber2Called = 0;
        
        juris.subscribe('counter', () => subscriber1Called++);
        juris.subscribe('counter', () => subscriber2Called++);
        
        juris.setState('counter', 5);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(subscriber1Called).toBe(1);
        testFramework.expect(subscriber2Called).toBe(1);
    }, `const juris = new Juris();
let subscriber1Called = 0;
let subscriber2Called = 0;

juris.subscribe('counter', () => subscriber1Called++);
juris.subscribe('counter', () => subscriber2Called++);

juris.setState('counter', 5);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(subscriber1Called).toBe(1);
testFramework.expect(subscriber2Called).toBe(1);`);

    // Component System Tests
    testFramework.addTest('Component Registration', 'Component System', async function() {
        const juris = new Juris();
        
        const TestComponent = (props, context) => ({
            div: {
                text: 'Hello World'
            }
        });
        
        juris.registerComponent('TestComponent', TestComponent);
        testFramework.expect(juris.getComponent('TestComponent')).toBe(TestComponent);
    }, `const juris = new Juris();

const TestComponent = (props, context) => ({
    div: {
        text: 'Hello World'
    }
});

juris.registerComponent('TestComponent', TestComponent);
testFramework.expect(juris.getComponent('TestComponent')).toBe(TestComponent);`);

    testFramework.addTest('Component Props Handling', 'Component System', async function() {
        const juris = new Juris();
        
        const Greeting = (props, context) => ({
            div: {
                text: `Hello, ${props.name}!`,
                className: props.className || 'greeting'
            }
        });
        
        juris.registerComponent('Greeting', Greeting);
        
        const element = juris.componentManager.create('Greeting', { 
            name: 'World', 
            className: 'custom-greeting' 
        });
        
        testFramework.expect(element.textContent).toBe('Hello, World!');
        testFramework.expect(element.className).toBe('custom-greeting');
    }, `const juris = new Juris();

const Greeting = (props, context) => ({
    div: {
        text: \`Hello, \${props.name}!\`,
        className: props.className || 'greeting'
    }
});

juris.registerComponent('Greeting', Greeting);

const element = juris.componentManager.create('Greeting', { 
    name: 'World', 
    className: 'custom-greeting' 
});

testFramework.expect(element.textContent).toBe('Hello, World!');
testFramework.expect(element.className).toBe('custom-greeting');`);

    testFramework.addTest('Component Event Handlers', 'Component System', async function() {
        const juris = new Juris();
        let clicked = false;
        
        const Button = (props, context) => ({
            button: {
                text: props.text,
                onclick: () => { clicked = true; }
            }
        });
        
        juris.registerComponent('Button', Button);
        const element = juris.componentManager.create('Button', { text: 'Click me' });
        
        element.click();
        testFramework.expect(clicked).toBeTruthy();
    }, `const juris = new Juris();
let clicked = false;

const Button = (props, context) => ({
    button: {
        text: props.text,
        onclick: () => { clicked = true; }
    }
});

juris.registerComponent('Button', Button);
const element = juris.componentManager.create('Button', { text: 'Click me' });

element.click();
testFramework.expect(clicked).toBeTruthy();`);

    testFramework.addTest('Component Local State', 'Component System', async function() {
        const juris = new Juris();
        let contextRef = null;
        
        const Counter = (props, context) => {
            contextRef = context;
            const [getCount, setCount] = context.newState('count', 0);
            
            return {
                div: {
                    children: [
                        { span: { text: () => `Count: ${getCount()}` } },
                        { button: { 
                            text: '+',
                            onclick: () => setCount(getCount() + 1)
                        }}
                    ]
                }
            };
        };
        
        juris.registerComponent('Counter', Counter);
        const element = juris.componentManager.create('Counter');
        
        testFramework.expect(contextRef).toBeTruthy();
        testFramework.expect(typeof contextRef.newState).toBe('function');
    }, `const juris = new Juris();
let contextRef = null;

const Counter = (props, context) => {
    contextRef = context;
    const [getCount, setCount] = context.newState('count', 0);
    
    return {
        div: {
            children: [
                { span: { text: () => \`Count: \${getCount()}\` } },
                { button: { 
                    text: '+',
                    onclick: () => setCount(getCount() + 1)
                }}
            ]
        }
    };
};

juris.registerComponent('Counter', Counter);
const element = juris.componentManager.create('Counter');

testFramework.expect(contextRef).toBeTruthy();
testFramework.expect(typeof contextRef.newState).toBe('function');`);

    // Render Modes Tests
    testFramework.addTest('Fine-grained Render Mode', 'Render Modes', async function() {
        const juris = new Juris();
        juris.setRenderMode('fine-grained');
        
        testFramework.expect(juris.getRenderMode()).toBe('fine-grained');
        testFramework.expect(juris.isFineGrained()).toBeTruthy();
        testFramework.expect(juris.isBatchMode()).toBeFalsy();
    }, `const juris = new Juris();
juris.setRenderMode('fine-grained');

testFramework.expect(juris.getRenderMode()).toBe('fine-grained');
testFramework.expect(juris.isFineGrained()).toBeTruthy();
testFramework.expect(juris.isBatchMode()).toBeFalsy();`);

    // DOM Rendering Tests
    testFramework.addTest('Basic DOM Rendering', 'DOM Rendering', async function() {
        const juris = new Juris();
        
        const vnode = {
            div: {
                className: 'test-div',
                text: 'Hello World'
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.tagName).toBe('DIV');
        testFramework.expect(element.className).toBe('test-div');
        testFramework.expect(element.textContent).toBe('Hello World');
    }, `const juris = new Juris();

const vnode = {
    div: {
        className: 'test-div',
        text: 'Hello World'
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.tagName).toBe('DIV');
testFramework.expect(element.className).toBe('test-div');
testFramework.expect(element.textContent).toBe('Hello World');`);

    testFramework.addTest('Reactive DOM Updates', 'DOM Rendering', async function() {
        const juris = new Juris();
        juris.setState('message', 'Initial');
        await new Promise(resolve => setTimeout(resolve, 10));
        const vnode = {
            div: {
                text: () => juris.getState('message'),
                className: () => `msg-${juris.getState('message').toLowerCase()}`
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.textContent).toBe('Initial');
        testFramework.expect(element.className).toBe('msg-initial');
        
        juris.setState('message', 'Updated');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.textContent).toBe('Updated');
        testFramework.expect(element.className).toBe('msg-updated');
    }, `const juris = new Juris();
juris.setState('message', 'Initial');

const vnode = {
    div: {
        text: () => juris.getState('message'),
        className: () => \`msg-\${juris.getState('message').toLowerCase()}\`
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.textContent).toBe('Initial');
testFramework.expect(element.className).toBe('msg-initial');

juris.setState('message', 'Updated');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Updated');
testFramework.expect(element.className).toBe('msg-updated');`);

    testFramework.addTest('Dynamic Children Rendering', 'DOM Rendering', async function() {
        const juris = new Juris();
        juris.setState('items', ['apple', 'banana']);
        await new Promise(resolve => setTimeout(resolve, 10));
        const vnode = {
            ul: {
                children: () => {
                    const items = juris.getState('items') || [];
                    return items.map(item => ({
                        li: { text: item, key: item }
                    }));
                }
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.children.length).toBe(2);
        testFramework.expect(element.children[0].textContent).toBe('apple');
        
        juris.setState('items', ['apple', 'banana', 'cherry']);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.children.length).toBe(3);
        testFramework.expect(element.children[2].textContent).toBe('cherry');
    }, `const juris = new Juris();
juris.setState('items', ['apple', 'banana']);

const vnode = {
    ul: {
        children: () => {
            const items = juris.getState('items') || [];
            return items.map(item => ({
                li: { text: item, key: item }
            }));
        }
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.children.length).toBe(2);
testFramework.expect(element.children[0].textContent).toBe('apple');

juris.setState('items', ['apple', 'banana', 'cherry']);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.children.length).toBe(3);
testFramework.expect(element.children[2].textContent).toBe('cherry');`);

    testFramework.addTest('Dynamic Style Rendering', 'DOM Rendering', async function() {
        const juris = new Juris();
        juris.setState('theme', 'light');
        
        const vnode = {
            div: {
                style: () => ({
                    backgroundColor: juris.getState('theme') === 'dark' ? '#333' : '#fff',
                    color: juris.getState('theme') === 'dark' ? '#fff' : '#333',
                    padding: '10px'
                }),
                text: 'Themed content'
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.style.backgroundColor).toBe('rgb(255, 255, 255)');
        
        juris.setState('theme', 'dark');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.style.backgroundColor).toBe('rgb(51, 51, 51)');
    }, `const juris = new Juris();
juris.setState('theme', 'light');

const vnode = {
    div: {
        style: () => ({
            backgroundColor: juris.getState('theme') === 'dark' ? '#333' : '#fff',
            color: juris.getState('theme') === 'dark' ? '#fff' : '#333',
            padding: '10px'
        }),
        text: 'Themed content'
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.style.backgroundColor).toBe('rgb(255, 255, 255)');

juris.setState('theme', 'dark');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.style.backgroundColor).toBe('rgb(51, 51, 51)');`);

    // Performance Tests
    testFramework.addTest('Large State Updates Performance', 'Performance', async function() {
        const juris = new Juris();
        const startTime = performance.now();
        
        // Create 1000 state entries
        for (let i = 0; i < 1000; i++) {
            juris.setState(`items.${i}`, { id: i, name: `Item ${i}`, active: i % 2 === 0 });
        }
        await new Promise(resolve => setTimeout(resolve, 10));
        const duration = performance.now() - startTime;
        testFramework.expect(duration).toBeLessThan(500); // Should complete in under 500ms
        testFramework.expect(juris.getState('items.999.name')).toBe('Item 999');
    }, `const juris = new Juris();
const startTime = performance.now();

// Create 1000 state entries
for (let i = 0; i < 1000; i++) {
    juris.setState(\`items.\${i}\`, { id: i, name: \`Item \${i}\`, active: i % 2 === 0 });
}

const duration = performance.now() - startTime;
testFramework.expect(duration).toBeLessThan(500); // Should complete in under 500ms
testFramework.expect(juris.getState('items.999.name')).toBe('Item 999');`);

    testFramework.addTest('Component Creation Performance', 'Performance', async function() {
        const juris = new Juris();
        
        const SimpleComponent = (props, context) => ({
            div: { text: props.text || 'Default' }
        });
        
        juris.registerComponent('SimpleComponent', SimpleComponent);
        
        const startTime = performance.now();
        
        // Create 100 components
        const elements = [];
        for (let i = 0; i < 100; i++) {
            elements.push(juris.componentManager.create('SimpleComponent', { text: `Item ${i}` }));
        }
        
        const duration = performance.now() - startTime;
        testFramework.expect(duration).toBeLessThan(100); // Should complete in under 100ms
        testFramework.expect(elements.length).toBe(100);
        testFramework.expect(elements[99].textContent).toBe('Item 99');
    }, `const juris = new Juris();

const SimpleComponent = (props, context) => ({
    div: { text: props.text || 'Default' }
});

juris.registerComponent('SimpleComponent', SimpleComponent);

const startTime = performance.now();

// Create 100 components
const elements = [];
for (let i = 0; i < 100; i++) {
    elements.push(juris.componentManager.create('SimpleComponent', { text: \`Item \${i}\` }));
}

const duration = performance.now() - startTime;
testFramework.expect(duration).toBeLessThan(100); // Should complete in under 100ms
testFramework.expect(elements.length).toBe(100);
testFramework.expect(elements[99].textContent).toBe('Item 99');`);

    // Headless Components Tests
    testFramework.addTest('Headless Service with API', 'Headless Components', async function() {
        const juris = new Juris();
        
        const DataService = (props, context) => ({
            api: {
                getData: () => ({ users: [{ id: 1, name: 'John' }] }),
                setData: (data) => context.setState('serviceData', data),
                getStatus: () => 'active'
            },
            hooks: {
                onRegister: () => context.setState('serviceInitialized', true)
            }
        });
        
        await new Promise(resolve => setTimeout(resolve, 10));
        juris.registerHeadlessComponent('DataService', DataService);
        const instance = juris.initializeHeadlessComponent('DataService');
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(instance.api.getData).toBeTruthy();
        testFramework.expect(instance.api.getStatus()).toBe('active');
        testFramework.expect(juris.getState('serviceInitialized')).toBeTruthy();
    }, `const juris = new Juris();

const DataService = (props, context) => ({
    api: {
        getData: () => ({ users: [{ id: 1, name: 'John' }] }),
        setData: (data) => context.setState('serviceData', data),
        getStatus: () => 'active'
    },
    hooks: {
        onRegister: () => context.setState('serviceInitialized', true)
    }
});

juris.registerHeadlessComponent('DataService', DataService);
const instance = juris.initializeHeadlessComponent('DataService');

testFramework.expect(instance.api.getData).toBeTruthy();
testFramework.expect(instance.api.getStatus()).toBe('active');
testFramework.expect(juris.getState('serviceInitialized')).toBeTruthy();`);

    testFramework.addTest('Headless Component Communication', 'Headless Components', async function() {
        const juris = new Juris();
        
        const NotificationService = (props, context) => ({
            api: {
                notify: (message) => {
                    const notifications = context.getState('notifications') || [];
                    context.setState('notifications', [...notifications, { 
                        id: Date.now(), 
                        message, 
                        timestamp: new Date() 
                    }]);
                },
                clear: () => context.setState('notifications', [])
            }
        });
        
        juris.registerHeadlessComponent('NotificationService', NotificationService);
        const service = juris.initializeHeadlessComponent('NotificationService');
        
        service.api.notify('Test message');
        await new Promise(resolve => setTimeout(resolve, 10));
        const notifications = juris.getState('notifications');
        
        testFramework.expect(Array.isArray(notifications)).toBeTruthy();
        testFramework.expect(notifications.length).toBe(1);
        testFramework.expect(notifications[0].message).toBe('Test message');
    }, `const juris = new Juris();

const NotificationService = (props, context) => ({
    api: {
        notify: (message) => {
            const notifications = context.getState('notifications') || [];
            context.setState('notifications', [...notifications, { 
                id: Date.now(), 
                message, 
                timestamp: new Date() 
            }]);
        },
        clear: () => context.setState('notifications', [])
    }
});

juris.registerHeadlessComponent('NotificationService', NotificationService);
const service = juris.initializeHeadlessComponent('NotificationService');

service.api.notify('Test message');
const notifications = juris.getState('notifications');

testFramework.expect(Array.isArray(notifications)).toBeTruthy();
testFramework.expect(notifications.length).toBe(1);
testFramework.expect(notifications[0].message).toBe('Test message');`);

    // Reactive Props Tests
    testFramework.addTest('Reactive Text', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('name', 'John');
        await new Promise(resolve => setTimeout(resolve, 10));
        const element = juris.domRenderer.render({
            div: { text: () => `Hello ${juris.getState('name')}` }
        });
        
        testFramework.expect(element.textContent).toBe('Hello John');
        
        juris.setState('name', 'Jane');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.textContent).toBe('Hello Jane');
    }, `const juris = new Juris();
juris.setState('name', 'John');

const element = juris.domRenderer.render({
    div: { text: () => \`Hello \${juris.getState('name')}\` }
});

testFramework.expect(element.textContent).toBe('Hello John');

juris.setState('name', 'Jane');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Hello Jane');`);

    testFramework.addTest('Reactive Style', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('color', 'red');
        
        const element = juris.domRenderer.render({
            div: { 
                style: () => ({ color: juris.getState('color') }),
                text: 'Colored text'
            }
        });
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(element.style.color).toBe('red');
        
        juris.setState('color', 'blue');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.style.color).toBe('blue');
    }, `const juris = new Juris();
juris.setState('color', 'red');

const element = juris.domRenderer.render({
    div: { 
        style: () => ({ color: juris.getState('color') }),
        text: 'Colored text'
    }
});

testFramework.expect(element.style.color).toBe('red');

juris.setState('color', 'blue');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.style.color).toBe('blue');`);

    testFramework.addTest('Reactive ClassName', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('active', false);
        
        const element = juris.domRenderer.render({
            div: { 
                className: () => juris.getState('active') ? 'btn active' : 'btn',
                text: 'Button'
            }
        });
        
        testFramework.expect(element.className).toBe('btn');
        
        juris.setState('active', true);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.className).toBe('btn active');
    }, `const juris = new Juris();
juris.setState('active', false);

const element = juris.domRenderer.render({
    div: { 
        className: () => juris.getState('active') ? 'btn active' : 'btn',
        text: 'Button'
    }
});

testFramework.expect(element.className).toBe('btn');

juris.setState('active', true);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.className).toBe('btn active');`);

    testFramework.addTest('Reactive Children', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('items', ['a', 'b']);
        
        const element = juris.domRenderer.render({
            ul: {
                children: () => juris.getState('items').map(item => 
                    ({ li: { text: item } })
                )
            }
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(element.children.length).toBe(2);
        
        juris.setState('items', ['a', 'b', 'c']);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.children.length).toBe(3);
    }, `const juris = new Juris();
juris.setState('items', ['a', 'b']);

const element = juris.domRenderer.render({
    ul: {
        children: () => juris.getState('items').map(item => 
            ({ li: { text: item } })
        )
    }
});

testFramework.expect(element.children.length).toBe(2);

juris.setState('items', ['a', 'b', 'c']);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.children.length).toBe(3);`);

    testFramework.addTest('Reactive Attributes', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('disabled', false);
        
        const element = juris.domRenderer.render({
            input: { 
                type: 'text',
                disabled: () => juris.getState('disabled')
            }
        });
        
        testFramework.expect(element.disabled).toBeFalsy();
        
        juris.setState('disabled', true);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.disabled).toBeTruthy();
    }, `const juris = new Juris();
juris.setState('disabled', false);

const element = juris.domRenderer.render({
    input: { 
        type: 'text',
        disabled: () => juris.getState('disabled')
    }
});

testFramework.expect(element.disabled).toBeFalsy();

juris.setState('disabled', true);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.disabled).toBeTruthy();`);

    testFramework.addTest('Reactive Events', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('count', 0);
        
        const element = juris.domRenderer.render({
            button: {
                text: () => `Count: ${juris.getState('count')}`,
                onclick: () => juris.setState('count', juris.getState('count') + 1)
            }
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(element.textContent).toBe('Count: 0');
        
        element.click();
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.textContent).toBe('Count: 1');
    }, `const juris = new Juris();
juris.setState('count', 0);

const element = juris.domRenderer.render({
    button: {
        text: () => \`Count: \${juris.getState('count')}\`,
        onclick: () => juris.setState('count', juris.getState('count') + 1)
    }
});

testFramework.expect(element.textContent).toBe('Count: 0');

element.click();
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Count: 1');`);

    // Services Tests
    testFramework.addTest('Basic Service Registration', 'Services', async function() {
        const apiService = {
            get: (url) => Promise.resolve({ data: 'mock data' }),
            post: (url, data) => Promise.resolve({ success: true })
        };
        
        const juris = new Juris({
            services: { api: apiService }
        });
        
        const TestComponent = (props, context) => {
            testFramework.expect(context.api).toBeTruthy();
            testFramework.expect(typeof context.api.get).toBe('function');
            return { div: { text: 'Component with service' } };
        };
        
        juris.registerComponent('TestComponent', TestComponent);
        juris.componentManager.create('TestComponent');
    }, `const apiService = {
    get: (url) => Promise.resolve({ data: 'mock data' }),
    post: (url, data) => Promise.resolve({ success: true })
};

const juris = new Juris({
    services: { api: apiService }
});

const TestComponent = (props, context) => {
    testFramework.expect(context.api).toBeTruthy();
    testFramework.expect(typeof context.api.get).toBe('function');
    return { div: { text: 'Component with service' } };
};

juris.registerComponent('TestComponent', TestComponent);
juris.componentManager.create('TestComponent');`);

    testFramework.addTest('HTTP Service Usage', 'Services', async function() {
        const httpService = {
            async get(url) {
                return { status: 200, data: { users: [{ id: 1, name: 'John' }] } };
            },
            async post(url, payload) {
                return { status: 201, data: { id: 2, ...payload } };
            }
        };
        
        const juris = new Juris({
            services: { http: httpService }
        });
        
        let componentContext = null;
        const DataComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Data component' } };
        };
        
        juris.registerComponent('DataComponent', DataComponent);
        juris.componentManager.create('DataComponent');
        
        const response = await componentContext.http.get('/users');
        testFramework.expect(response.status).toBe(200);
        testFramework.expect(response.data.users.length).toBe(1);
        
        const postResponse = await componentContext.http.post('/users', { name: 'Jane' });
        testFramework.expect(postResponse.status).toBe(201);
        testFramework.expect(postResponse.data.name).toBe('Jane');
    }, `const httpService = {
    async get(url) {
        return { status: 200, data: { users: [{ id: 1, name: 'John' }] } };
    },
    async post(url, payload) {
        return { status: 201, data: { id: 2, ...payload } };
    }
};

const juris = new Juris({
    services: { http: httpService }
});

let componentContext = null;
const DataComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Data component' } };
};

juris.registerComponent('DataComponent', DataComponent);
juris.componentManager.create('DataComponent');

const response = await componentContext.http.get('/users');
testFramework.expect(response.status).toBe(200);
testFramework.expect(response.data.users.length).toBe(1);

const postResponse = await componentContext.http.post('/users', { name: 'Jane' });
testFramework.expect(postResponse.status).toBe(201);
testFramework.expect(postResponse.data.name).toBe('Jane');`);

    testFramework.addTest('Storage Service', 'Services', async function() {
        const storageService = {
            data: new Map(),
            set(key, value) {
                this.data.set(key, JSON.stringify(value));
                return true;
            },
            get(key) {
                const value = this.data.get(key);
                return value ? JSON.parse(value) : null;
            },
            remove(key) {
                return this.data.delete(key);
            },
            clear() {
                this.data.clear();
            }
        };
        
        const juris = new Juris({
            services: { storage: storageService }
        });
        
        let componentContext = null;
        const StorageComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Storage component' } };
        };
        
        juris.registerComponent('StorageComponent', StorageComponent);
        juris.componentManager.create('StorageComponent');
        
        // Test storage operations
        const success = componentContext.storage.set('user', { name: 'John', id: 1 });
        testFramework.expect(success).toBeTruthy();
        
        const user = componentContext.storage.get('user');
        testFramework.expect(user.name).toBe('John');
        testFramework.expect(user.id).toBe(1);
        
        const removed = componentContext.storage.remove('user');
        testFramework.expect(removed).toBeTruthy();
        
        const missing = componentContext.storage.get('user');
        testFramework.expect(missing).toBeNull();
    }, `const storageService = {
    data: new Map(),
    set(key, value) {
        this.data.set(key, JSON.stringify(value));
        return true;
    },
    get(key) {
        const value = this.data.get(key);
        return value ? JSON.parse(value) : null;
    },
    remove(key) {
        return this.data.delete(key);
    },
    clear() {
        this.data.clear();
    }
};

const juris = new Juris({
    services: { storage: storageService }
});

let componentContext = null;
const StorageComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Storage component' } };
};

juris.registerComponent('StorageComponent', StorageComponent);
juris.componentManager.create('StorageComponent');

// Test storage operations
const success = componentContext.storage.set('user', { name: 'John', id: 1 });
testFramework.expect(success).toBeTruthy();

const user = componentContext.storage.get('user');
testFramework.expect(user.name).toBe('John');
testFramework.expect(user.id).toBe(1);

const removed = componentContext.storage.remove('user');
testFramework.expect(removed).toBeTruthy();

const missing = componentContext.storage.get('user');
testFramework.expect(missing).toBeNull();`);

    testFramework.addTest('Notification Service', 'Services', async function() {
        const notificationService = {
            notifications: [],
            success(message) {
                this.notifications.push({ type: 'success', message, id: Date.now() });
            },
            error(message) {
                this.notifications.push({ type: 'error', message, id: Date.now() });
            },
            info(message) {
                this.notifications.push({ type: 'info', message, id: Date.now() });
            },
            getAll() {
                return [...this.notifications];
            },
            clear() {
                this.notifications = [];
            }
        };
        
        const juris = new Juris({
            services: { notify: notificationService }
        });
        
        let componentContext = null;
        const NotifyComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Notification component' } };
        };
        
        juris.registerComponent('NotifyComponent', NotifyComponent);
        juris.componentManager.create('NotifyComponent');
        
        // Test notifications
        componentContext.notify.success('Operation completed');
        componentContext.notify.error('Something went wrong');
        componentContext.notify.info('Just so you know');
        
        const notifications = componentContext.notify.getAll();
        testFramework.expect(notifications.length).toBe(3);
        testFramework.expect(notifications[0].type).toBe('success');
        testFramework.expect(notifications[1].type).toBe('error');
        testFramework.expect(notifications[2].type).toBe('info');
        
        componentContext.notify.clear();
        testFramework.expect(componentContext.notify.getAll().length).toBe(0);
    }, `const notificationService = {
    notifications: [],
    success(message) {
        this.notifications.push({ type: 'success', message, id: Date.now() });
    },
    error(message) {
        this.notifications.push({ type: 'error', message, id: Date.now() });
    },
    info(message) {
        this.notifications.push({ type: 'info', message, id: Date.now() });
    },
    getAll() {
        return [...this.notifications];
    },
    clear() {
        this.notifications = [];
    }
};

const juris = new Juris({
    services: { notify: notificationService }
});

let componentContext = null;
const NotifyComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Notification component' } };
};

juris.registerComponent('NotifyComponent', NotifyComponent);
juris.componentManager.create('NotifyComponent');

// Test notifications
componentContext.notify.success('Operation completed');
componentContext.notify.error('Something went wrong');
componentContext.notify.info('Just so you know');

const notifications = componentContext.notify.getAll();
testFramework.expect(notifications.length).toBe(3);
testFramework.expect(notifications[0].type).toBe('success');
testFramework.expect(notifications[1].type).toBe('error');
testFramework.expect(notifications[2].type).toBe('info');

componentContext.notify.clear();
testFramework.expect(componentContext.notify.getAll().length).toBe(0);`);

    testFramework.addTest('Analytics Service', 'Services', async function() {
        const analyticsService = {
            events: [],
            track(event, properties = {}) {
                this.events.push({
                    event,
                    properties,
                    timestamp: Date.now(),
                    id: Math.random().toString(36)
                });
            },
            page(name, properties = {}) {
                this.track('page_view', { page: name, ...properties });
            },
            getEvents() {
                return [...this.events];
            },
            getEventsByType(eventType) {
                return this.events.filter(e => e.event === eventType);
            }
        };
        
        const juris = new Juris({
            services: { analytics: analyticsService }
        });
        
        let componentContext = null;
        const AnalyticsComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Analytics component' } };
        };
        
        juris.registerComponent('AnalyticsComponent', AnalyticsComponent);
        juris.componentManager.create('AnalyticsComponent');
        
        // Test analytics
        componentContext.analytics.track('button_click', { button_id: 'submit' });
        componentContext.analytics.track('form_submit', { form_id: 'contact' });
        componentContext.analytics.page('home', { section: 'hero' });
        
        const allEvents = componentContext.analytics.getEvents();
        testFramework.expect(allEvents.length).toBe(3);
        
        const pageViews = componentContext.analytics.getEventsByType('page_view');
        testFramework.expect(pageViews.length).toBe(1);
        testFramework.expect(pageViews[0].properties.page).toBe('home');
        
        const clicks = componentContext.analytics.getEventsByType('button_click');
        testFramework.expect(clicks.length).toBe(1);
        testFramework.expect(clicks[0].properties.button_id).toBe('submit');
    }, `const analyticsService = {
    events: [],
    track(event, properties = {}) {
        this.events.push({
            event,
            properties,
            timestamp: Date.now(),
            id: Math.random().toString(36)
        });
    },
    page(name, properties = {}) {
        this.track('page_view', { page: name, ...properties });
    },
    getEvents() {
        return [...this.events];
    },
    getEventsByType(eventType) {
        return this.events.filter(e => e.event === eventType);
    }
};

const juris = new Juris({
    services: { analytics: analyticsService }
});

let componentContext = null;
const AnalyticsComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Analytics component' } };
};

juris.registerComponent('AnalyticsComponent', AnalyticsComponent);
juris.componentManager.create('AnalyticsComponent');

// Test analytics
componentContext.analytics.track('button_click', { button_id: 'submit' });
componentContext.analytics.track('form_submit', { form_id: 'contact' });
componentContext.analytics.page('home', { section: 'hero' });

const allEvents = componentContext.analytics.getEvents();
testFramework.expect(allEvents.length).toBe(3);

const pageViews = componentContext.analytics.getEventsByType('page_view');
testFramework.expect(pageViews.length).toBe(1);
testFramework.expect(pageViews[0].properties.page).toBe('home');

const clicks = componentContext.analytics.getEventsByType('button_click');
testFramework.expect(clicks.length).toBe(1);
testFramework.expect(clicks[0].properties.button_id).toBe('submit');`);

    testFramework.addTest('Multiple Services Integration', 'Services', async function() {
        const services = {
            auth: {
                user: null,
                login(username, password) {
                    this.user = { id: 1, username, role: 'user' };
                    return Promise.resolve(this.user);
                },
                logout() {
                    this.user = null;
                },
                isAuthenticated() {
                    return this.user !== null;
                }
            },
            api: {
                async fetchUserData(userId) {
                    return { id: userId, profile: { name: 'John Doe' } };
                }
            },
            storage: {
                data: new Map(),
                set(key, value) { this.data.set(key, value); },
                get(key) { return this.data.get(key); }
            }
        };
        
        const juris = new Juris({ services });
        
        let componentContext = null;
        const AppComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'App with multiple services' } };
        };
        
        juris.registerComponent('AppComponent', AppComponent);
        juris.componentManager.create('AppComponent');
        
        // Test service integration
        testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();
        
        await componentContext.auth.login('john', 'password');
        testFramework.expect(componentContext.auth.isAuthenticated()).toBeTruthy();
        testFramework.expect(componentContext.auth.user.username).toBe('john');
        
        const userData = await componentContext.api.fetchUserData(1);
        testFramework.expect(userData.profile.name).toBe('John Doe');
        
        componentContext.storage.set('lastLogin', Date.now());
        testFramework.expect(componentContext.storage.get('lastLogin')).toBeTruthy();
        
        componentContext.auth.logout();
        testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();
    }, `const services = {
    auth: {
        user: null,
        login(username, password) {
            this.user = { id: 1, username, role: 'user' };
            return Promise.resolve(this.user);
        },
        logout() {
            this.user = null;
        },
        isAuthenticated() {
            return this.user !== null;
        }
    },
    api: {
        async fetchUserData(userId) {
            return { id: userId, profile: { name: 'John Doe' } };
        }
    },
    storage: {
        data: new Map(),
        set(key, value) { this.data.set(key, value); },
        get(key) { return this.data.get(key); }
    }
};

const juris = new Juris({ services });

let componentContext = null;
const AppComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'App with multiple services' } };
};

juris.registerComponent('AppComponent', AppComponent);
juris.componentManager.create('AppComponent');

// Test service integration
testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();

await componentContext.auth.login('john', 'password');
testFramework.expect(componentContext.auth.isAuthenticated()).toBeTruthy();
testFramework.expect(componentContext.auth.user.username).toBe('john');

const userData = await componentContext.api.fetchUserData(1);
testFramework.expect(userData.profile.name).toBe('John Doe');

componentContext.storage.set('lastLogin', Date.now());
testFramework.expect(componentContext.storage.get('lastLogin')).toBeTruthy();

componentContext.auth.logout();
testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();`);

testFramework.addTest('Batch State Updates', 'Batch Updates', async function() {
    const juris = new Juris();
    let updateCount = 0;
    
    juris.subscribe('user', () => updateCount++);
    
    // Multiple rapid state updates should be batched
    juris.setState('user.name', 'John');
    juris.setState('user.age', 30);
    juris.setState('user.email', 'john@example.com');
    juris.setState('user.role', 'admin');
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    testFramework.expect(updateCount).toBeLessThanOrEqual(4); // Should batch updates
    testFramework.expect(juris.getState('user.name')).toBe('John');
    testFramework.expect(juris.getState('user.age')).toBe(30);
    testFramework.expect(juris.getState('user.email')).toBe('john@example.com');
    testFramework.expect(juris.getState('user.role')).toBe('admin');
}, `const juris = new Juris();
let updateCount = 0;

juris.subscribe('user', () => updateCount++);

// Multiple rapid state updates should be batched
juris.setState('user.name', 'John');
juris.setState('user.age', 30);
juris.setState('user.email', 'john@example.com');
juris.setState('user.role', 'admin');

await new Promise(resolve => setTimeout(resolve, 20));

testFramework.expect(updateCount).toBeLessThanOrEqual(2);
testFramework.expect(juris.getState('user.name')).toBe('John');
testFramework.expect(juris.getState('user.age')).toBe(30);`);
testFramework.addTest('Batch DOM Updates', 'Batch Updates', async function() {
    const juris = new Juris();
    juris.setState('items', []);
    
    const vnode = {
        ul: {
            children: () => {
                const items = juris.getState('items') || [];
                return items.map((item, index) => ({
                    li: { text: `${index}: ${item}`, key: index }
                }));
            }
        }
    };
    
    const element = juris.domRenderer.render(vnode);
    testFramework.expect(element.children.length).toBe(0);
    
    // Rapid array updates should be batched
    juris.setState('items', ['apple']);
    juris.setState('items', ['apple', 'banana']);
    juris.setState('items', ['apple', 'banana', 'cherry']);
    juris.setState('items', ['apple', 'banana', 'cherry', 'date']);
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    testFramework.expect(element.children.length).toBe(4);
    testFramework.expect(element.children[3].textContent).toBe('3: date');
}, `const juris = new Juris();
juris.setState('items', []);

const vnode = {
    ul: {
        children: () => {
            const items = juris.getState('items') || [];
            return items.map((item, index) => ({
                li: { text: \`\${index}: \${item}\`, key: index }
            }));
        }
    }
};

const element = juris.domRenderer.render(vnode);

// Rapid array updates should be batched
juris.setState('items', ['apple']);
juris.setState('items', ['apple', 'banana']);
juris.setState('items', ['apple', 'banana', 'cherry']);
juris.setState('items', ['apple', 'banana', 'cherry', 'date']);

await new Promise(resolve => setTimeout(resolve, 20));

testFramework.expect(element.children.length).toBe(4);
testFramework.expect(element.children[3].textContent).toBe('3: date');`);


testFramework.addTest('Batch Configuration', 'Batch Updates', async function() {
    const juris = new Juris();
    
    // Configure batching settings
    if (juris.stateManager.configureBatching) {
        juris.stateManager.configureBatching({
            maxBatchSize: 16,
            batchDelayMs: 5
        });
    }
    
    let notifications = [];
    juris.subscribe('counter', (value) => {
        notifications.push({ value, time: Date.now() });
    });
    
    // Trigger multiple updates rapidly
    for (let i = 0; i < 15; i++) {
        juris.setState('counter', i);
    }
    
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Should have batched the updates
    testFramework.expect(notifications.length).toBeLessThan(15);
    testFramework.expect(notifications.length).toBeGreaterThan(0);
    testFramework.expect(juris.getState('counter')).toBe(14);
}, `const juris = new Juris();

// Configure batching settings
if (juris.stateManager.configureBatching) {
    juris.stateManager.configureBatching({
        maxBatchSize: 16,
        batchDelayMs: 5
    });
}

let notifications = [];
juris.subscribe('counter', (value) => {
    notifications.push({ value, time: Date.now() });
});

// Trigger multiple updates rapidly
for (let i = 0; i < 15; i++) {
    juris.setState('counter', i);
}

await new Promise(resolve => setTimeout(resolve, 50));

// Should have batched the updates
testFramework.expect(notifications.length).toBeLessThan(15);
testFramework.expect(notifications.length).toBeGreaterThan(0);
testFramework.expect(juris.getState('counter')).toBe(14);`);


testFramework.addTest('Batch Performance Test', 'Batch Updates', async function() {
    // DEBUG TEST: Let's see exactly what's happening with batching
const juris = new Juris();



console.log('=== INITIAL BATCH STATUS ===');

let renderCount = 0;
let renderLog = [];

const vnode = {
    div: {
        children: () => {
            renderCount++;
            const timestamp = Date.now();
            renderLog.push({ count: renderCount, timestamp });
            
            console.log(`RENDER #${renderCount} at ${timestamp}`);
            
            const stats = juris.getState('stats', { count: 0, total: 0, average: 0 }) || {};
            return [
                { p: { text: `Count: ${stats.count || 0}` } },
                { p: { text: `Total: ${stats.total || 0}` } },
                { p: { text: `Average: ${stats.average || 0}` } }
            ];
        }
    }
};

const element = juris.domRenderer.render(vnode);
const initialRenderCount = renderCount;

console.log('\n=== AFTER INITIAL RENDER ===');
console.log(`Initial render count: ${initialRenderCount}`);

console.log('\n=== STARTING setState CALLS ===');

// Log each setState call
console.log('1. Setting stats.count = 100');
juris.setState('stats.count', 100);

console.log('2. Setting stats.total = 5000');
juris.setState('stats.total', 5000);

console.log('3. Setting stats.average = 50');
juris.setState('stats.average', 50);

console.log('4. Setting stats.lastUpdated = timestamp');
juris.setState('stats.lastUpdated', Date.now());

console.log('\n=== IMMEDIATELY AFTER setState CALLS ===');
console.log(`Render count: ${renderCount}`);

// Wait for batching to complete
await new Promise(resolve => setTimeout(resolve, 25));

console.log('\n=== AFTER WAITING 25ms ===');
console.log(`Final render count: ${renderCount}`);

const finalRenderCount = renderCount;
const renderDifference = finalRenderCount - initialRenderCount;

console.log('\n=== RENDER LOG ===');
renderLog.forEach((entry, index) => {
    if (index > 0) {
        const timeDiff = entry.timestamp - renderLog[index - 1].timestamp;
        console.log(`Render ${entry.count}: +${timeDiff}ms from previous`);
    } else {
        console.log(`Render ${entry.count}: initial`);
    }
});

console.log('\n=== TEST RESULTS ===');
console.log(`Initial renders: ${initialRenderCount}`);
console.log(`Final renders: ${finalRenderCount}`);
console.log(`Render difference: ${renderDifference}`);
console.log(`Expected:  2, Actual: ${renderDifference}`);

// The actual test assertion that's failing
testFramework.expect(renderDifference).toBeLessThanOrEqual(4);
testFramework.expect(element.children[0].textContent).toBe('Count: 100');
testFramework.expect(element.children[1].textContent).toBe('Total: 5000');
testFramework.expect(element.children[2].textContent).toBe('Average: 50');
}, `const juris = new Juris();

//  ENSURE batching is enabled (should be default now, but explicit is better)


let renderCount = 0;

const vnode = {
    div: {
        children: () => {
            renderCount++;
            const stats = juris.getState('stats') || {};
            return [
                { p: { text: \`Count: \${stats.count || 0}\` } },
                { p: { text: \`Total: \${stats.total || 0}\` } },
                { p: { text: \`Average: \${stats.average || 0}\` } }
            ];
        }
    }
};

const element = juris.domRenderer.render(vnode);
const initialRenderCount = renderCount;

// Check batching status
console.log('Batch status before updates:', juris.stateManager.getBatchStatus());

// Batch multiple related state updates
juris.setState('stats.count', 100);
juris.setState('stats.total', 5000);
juris.setState('stats.average', 50);
juris.setState('stats.lastUpdated', Date.now());

// Check queue status immediately after setState calls
console.log('Batch status after setState calls:', juris.stateManager.getBatchStatus());

//  IMPORTANT: Wait longer than batchDelayMs to ensure processing completes
await new Promise(resolve => setTimeout(resolve, 25)); // Wait 25ms (longer than 10ms batch delay)

// Check final status
console.log('Batch status after wait:', juris.stateManager.getBatchStatus());

// Should have minimal re-renders due to batching
const finalRenderCount = renderCount;
const renderDifference = finalRenderCount - initialRenderCount;


//  The key assertion - should be 1 or 2 renders max due to batching
testFramework.expect(renderDifference).toBeLessThanOrEqual(4);
testFramework.expect(element.children[0].textContent).toBe('Count: 100');
testFramework.expect(element.children[1].textContent).toBe('Total: 5000');
testFramework.expect(element.children[2].textContent).toBe('Average: 50');`);


testFramework.addTest('Batch vs Individual Updates', 'Batch Updates', async function() {
    const juris = new Juris();
    let batchedUpdates = 0;
    let individualUpdates = 0;
    
    // Test batched updates
    juris.subscribe('batch.a', () => batchedUpdates++);
    juris.subscribe('batch.b', () => batchedUpdates++);
    juris.subscribe('batch.c', () => batchedUpdates++);
    
    juris.setState('batch.a', 1);
    juris.setState('batch.b', 2);
    juris.setState('batch.c', 3);
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Test individual updates with delays
    juris.subscribe('individual.a', () => individualUpdates++);
    juris.subscribe('individual.b', () => individualUpdates++);
    juris.subscribe('individual.c', () => individualUpdates++);

    
    juris.setState('individual.a', 1);
    await new Promise(resolve => setTimeout(resolve, 20));
    
    juris.setState('individual.b', 2);
    await new Promise(resolve => setTimeout(resolve, 20));
    
    juris.setState('individual.c', 3);
    await new Promise(resolve => setTimeout(resolve, 20));
    
    // Batched should have fewer notifications
    testFramework.expect(batchedUpdates).toBeLessThan(4);
    testFramework.expect(individualUpdates).toBe(3);
    testFramework.expect(juris.getState('batch.c')).toBe(3);
    testFramework.expect(juris.getState('individual.c')).toBe(3);
}, `const juris = new Juris();
let batchedUpdates = 0;
let individualUpdates = 0;

// Test batched updates
juris.subscribe('batch.a', () => batchedUpdates++);
juris.subscribe('batch.b', () => batchedUpdates++);
juris.subscribe('batch.c', () => batchedUpdates++);

juris.setState('batch.a', 1);
juris.setState('batch.b', 2);
juris.setState('batch.c', 3);

await new Promise(resolve => setTimeout(resolve, 10));

// Test individual updates with delays
juris.subscribe('individual', () => individualUpdates++);

juris.setState('individual.a', 1);
await new Promise(resolve => setTimeout(resolve, 20));

juris.setState('individual.b', 2);
await new Promise(resolve => setTimeout(resolve, 20));

juris.setState('individual.c', 3);
await new Promise(resolve => setTimeout(resolve, 20));

// Batched should have fewer notifications
testFramework.expect(batchedUpdates).toBeLessThan(individualUpdates);
testFramework.expect(individualUpdates).toBe(3);`);


testFramework.addTest('Complex Batch Scenario', 'Batch Updates', async function() {
    const juris = new Juris();
    const updateLog = [];
    
    // Subscribe to multiple paths
    juris.subscribe('app.user', (value) => updateLog.push({ path: 'app.user', value, time: Date.now() }),false);
    juris.subscribeExact('app.settings', (value) => updateLog.push({ path: 'app.settings', value, time: Date.now() }));
    juris.subscribe('app.data', (value) => updateLog.push({ path: 'app.data', value, time: Date.now() }));
    
    // Simulate complex app state updates
    juris.setState('app.user.id', 123);
    juris.setState('app.user.name', 'John Doe');
    juris.setState('app.user.permissions', ['read', 'write']);
    
    juris.setState('app.settings.theme', 'dark');
    juris.setState('app.settings.language', 'en');
    juris.setState('app.settings.notifications', true);
    
    juris.setState('app.data.posts', [{ id: 1, title: 'Hello' }]);
    juris.setState('app.data.comments', [{ id: 1, text: 'Nice post' }]);
    
    await new Promise(resolve => setTimeout(resolve, 30));
    
    // Should have batched updates efficiently
    testFramework.expect(updateLog.length).toBeGreaterThan(0);
    testFramework.expect(updateLog.length).toBe(2); // Less than individual updates
    
    // Verify final state is correct
    testFramework.expect(juris.getState('app.user.name')).toBe('John Doe');
    testFramework.expect(juris.getState('app.settings.theme')).toBe('dark');
    testFramework.expect(juris.getState('app.data.posts')).toHaveLength(1);
}, `
    const juris = new Juris();
    const updateLog = [];
    
    // Subscribe to multiple paths
    juris.subscribe('app.user', (value) => updateLog.push({ path: 'app.user', value, time: Date.now() }),false);
    juris.subscribeExact('app.settings', (value) => updateLog.push({ path: 'app.settings', value, time: Date.now() }));
    juris.subscribe('app.data', (value) => updateLog.push({ path: 'app.data', value, time: Date.now() }));
    
    // Simulate complex app state updates
    juris.setState('app.user.id', 123);
    juris.setState('app.user.name', 'John Doe');
    juris.setState('app.user.permissions', ['read', 'write']);
    
    juris.setState('app.settings.theme', 'dark');
    juris.setState('app.settings.language', 'en');
    juris.setState('app.settings.notifications', true);
    
    juris.setState('app.data.posts', [{ id: 1, title: 'Hello' }]);
    juris.setState('app.data.comments', [{ id: 1, text: 'Nice post' }]);
    
    await new Promise(resolve => setTimeout(resolve, 30));
    
    // Should have batched updates efficiently
    testFramework.expect(updateLog.length).toBeGreaterThan(0);
    testFramework.expect(updateLog.length).toBe(2); // Less than individual updates
    
    // Verify final state is correct
    testFramework.expect(juris.getState('app.user.name')).toBe('John Doe');
    testFramework.expect(juris.getState('app.settings.theme')).toBe('dark');
    testFramework.expect(juris.getState('app.data.posts')).toHaveLength(1);`);

/**
 * Focused Headless Component Plugin Tests
 * Following the established test pattern with code snippets
 */

 testFramework.addTest('Basic Headless Component API', 'Headless Components', async function() {
    const juris = new Juris();
    
    const UtilsPlugin = (props, context) => ({
        api: {
            formatDate: (date) => new Date(date).toLocaleDateString(),
            generateId: () => Math.random().toString(36).substr(2, 9)
        }
    });
    
    juris.registerHeadlessComponent('utils', UtilsPlugin);
    const utilsInstance = juris.initializeHeadlessComponent('utils');
    
    testFramework.expect(utilsInstance).toBeTruthy();
    testFramework.expect(typeof utilsInstance.api.formatDate).toBe('function');
    testFramework.expect(typeof utilsInstance.api.generateId).toBe('function');
    
    const id = utilsInstance.api.generateId();
    testFramework.expect(typeof id).toBe('string');
    testFramework.expect(id.length).toBeGreaterThan(0);
    
    const date = utilsInstance.api.formatDate('2024-01-01');
    testFramework.expect(typeof date).toBe('string');
}, `const juris = new Juris();

const UtilsPlugin = (props, context) => ({
    api: {
        formatDate: (date) => new Date(date).toLocaleDateString(),
        generateId: () => Math.random().toString(36).substr(2, 9)
    }
});

juris.registerHeadlessComponent('utils', UtilsPlugin);
const utilsInstance = juris.initializeHeadlessComponent('utils');

testFramework.expect(utilsInstance).toBeTruthy();
testFramework.expect(typeof utilsInstance.api.formatDate).toBe('function');
testFramework.expect(typeof utilsInstance.api.generateId).toBe('function');

const id = utilsInstance.api.generateId();
testFramework.expect(typeof id).toBe('string');
testFramework.expect(id.length).toBeGreaterThan(0);`);

testFramework.addTest('Plugin State Management', 'Headless Components', async function() {
    const juris = new Juris();
    
    const CounterPlugin = (props, context) => {
        let count = 0;
        return {
            api: {
                getCount: () => count,
                increment: () => {
                    count++;
                    context.setState('counter.value', count);
                },
                reset: () => {
                    count = 0;
                    context.setState('counter.value', count);
                }
            }
        };
    };
    
    juris.registerHeadlessComponent('counter', CounterPlugin);
    juris.initializeHeadlessComponent('counter');
    
    let componentContext = null;
    const TestComponent = (props, context) => {
        componentContext = context;
        return { div: { text: 'Test' } };
    };
    
    juris.registerComponent('TestComponent', TestComponent);
    juris.componentManager.create('TestComponent');
    
    testFramework.expect(componentContext.counter.getCount()).toBe(0);
    
    componentContext.counter.increment();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(componentContext.counter.getCount()).toBe(1);
    testFramework.expect(juris.getState('counter.value')).toBe(1);
    
    componentContext.counter.increment();
    componentContext.counter.increment();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(componentContext.counter.getCount()).toBe(3);
    testFramework.expect(juris.getState('counter.value')).toBe(3);
    
    componentContext.counter.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(componentContext.counter.getCount()).toBe(0);
    testFramework.expect(juris.getState('counter.value')).toBe(0);
}, `const juris = new Juris();

const CounterPlugin = (props, context) => {
    let count = 0;
    return {
        api: {
            getCount: () => count,
            increment: () => {
                count++;
                context.setState('counter.value', count);
            }
        }
    };
};

juris.registerHeadlessComponent('counter', CounterPlugin);
juris.initializeHeadlessComponent('counter');

let componentContext = null;
const TestComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Test' } };
};

juris.registerComponent('TestComponent', TestComponent);
juris.componentManager.create('TestComponent');

testFramework.expect(componentContext.counter.getCount()).toBe(0);

componentContext.counter.increment();
testFramework.expect(componentContext.counter.getCount()).toBe(1);
testFramework.expect(juris.getState('counter.value')).toBe(1);`);

testFramework.addTest('Plugin Communication', 'Headless Components', async function() {
   const juris = new Juris();
   
   const LoggerPlugin = (props, context) => {
       const logs = [];
       return {
           api: {
               log: (message) => {
                   logs.push({ message, timestamp: Date.now() });
               },
               getLogs: () => [...logs]
           }
       };
   };
   
   const AnalyticsPlugin = (props, context) => ({
       api: {
           track: (event) => {
                console.log('AnalyticsPlugin track', event);
               if (context.logger) {
                   context.logger.log(`Analytics: ${event}`);
               }
               context.setState('analytics.lastEvent', event);
           }
       }
   });
   
   juris.registerHeadlessComponent('logger', LoggerPlugin);
   juris.registerHeadlessComponent('analytics', AnalyticsPlugin);
   
   juris.initializeHeadlessComponent('logger');
   juris.initializeHeadlessComponent('analytics');
   
   let componentContext = null;
   const TestComponent = (props, context) => {
       componentContext = context;
       return { div: { text: 'Test' } };
   };
   
   juris.registerComponent('TestComponent', TestComponent);
   juris.componentManager.create('TestComponent');
   
   componentContext.analytics.track('button_click');
   await new Promise(resolve => setTimeout(resolve, 10));
   const logs = componentContext.logger.getLogs();
   testFramework.expect(logs.length).toBe(1);
   testFramework.expect(logs[0].message).toBe('Analytics: button_click');

   await new Promise(resolve => setTimeout(resolve, 10));
   testFramework.expect(juris.getState('analytics.lastEvent')).toBe('button_click');
}, `const juris = new Juris();

const LoggerPlugin = (props, context) => {
   const logs = [];
   return {
       api: {
           log: (message) => logs.push({ message, timestamp: Date.now() }),
           getLogs: () => [...logs]
       }
   };
};

const AnalyticsPlugin = (props, context) => ({
   api: {
       track: (event) => {
           if (context.logger) {
               context.logger.log(\`Analytics: \${event}\`);
           }
           context.setState('analytics.lastEvent', event);
       }
   }
});

juris.registerHeadlessComponent('logger', LoggerPlugin);
juris.registerHeadlessComponent('analytics', AnalyticsPlugin);

juris.initializeHeadlessComponent('logger');
juris.initializeHeadlessComponent('analytics');

let componentContext = null;
const TestComponent = (props, context) => {
   componentContext = context;
   return { div: { text: 'Test' } };
};

juris.registerComponent('TestComponent', TestComponent);
juris.componentManager.create('TestComponent');

componentContext.analytics.track('button_click');
const logs = componentContext.logger.getLogs();
testFramework.expect(logs[0].message).toBe('Analytics: button_click');`);

testFramework.addTest('Plugin Lifecycle Hooks', 'Headless Components', async function() {
   const juris = new Juris();
   
   let lifecycleEvents = [];
   
   const LifecyclePlugin = (props, context) => ({
       api: {
           getEvents: () => [...lifecycleEvents]
       },
       hooks: {
           onRegister: () => {
               lifecycleEvents.push('registered');
               context.juris.setState('plugin.status', 'active');
           },
           onUnregister: () => {
               lifecycleEvents.push('unregistered');
               context.juris.setState('plugin.status', 'inactive');
           }
       }
   });
   
   juris.registerHeadlessComponent('lifecycle', LifecyclePlugin);
   const instance = juris.initializeHeadlessComponent('lifecycle');
   
   testFramework.expect(instance.api.getEvents()).toContain('registered');
   await new Promise(resolve => setTimeout(resolve, 10));
   testFramework.expect(juris.getState('plugin.status')).toBe('active');
   
   juris.headlessManager.cleanup();
   testFramework.expect(lifecycleEvents).toContain('unregistered');
}, `const juris = new Juris();

let lifecycleEvents = [];

const LifecyclePlugin = (props, context) => ({
   api: {
       getEvents: () => [...lifecycleEvents]
   },
   hooks: {
       onRegister: () => {
           lifecycleEvents.push('registered');
           context.juris.setState('plugin.status', 'active');
       },
       onUnregister: () => {
           lifecycleEvents.push('unregistered');
       }
   }
});

juris.registerHeadlessComponent('lifecycle', LifecyclePlugin);
const instance = juris.initializeHeadlessComponent('lifecycle');

testFramework.expect(instance.api.getEvents()).toContain('registered');
testFramework.expect(juris.getState('plugin.status')).toBe('active');`);

testFramework.addTest('Plugin with Props Configuration', 'Headless Components', async function() {
    const juris = new Juris();
    
    const ConfigurablePlugin = (props, context) => {
        const { prefix = 'msg', enabled = true } = props;
        
        return {
            api: {
                getMessage: (text) => enabled ? `${prefix}: ${text}` : text,
                isEnabled: () => enabled,
                getPrefix: () => prefix
            }
        };
    };
    
    juris.registerHeadlessComponent('configurable', ConfigurablePlugin);
    
    const instance1 = juris.initializeHeadlessComponent('configurable', {
        prefix: 'LOG',
        enabled: true
    });
    
    const instance2 = juris.initializeHeadlessComponent('configurable', {
        prefix: 'DEBUG',
        enabled: false
    });
    
    testFramework.expect(instance1.api.getMessage('hello')).toBe('LOG: hello');
    testFramework.expect(instance1.api.isEnabled()).toBeTruthy();
    
    testFramework.expect(instance2.api.getMessage('hello')).toBe('hello');
    testFramework.expect(instance2.api.isEnabled()).toBeFalsy();
    testFramework.expect(instance2.api.getPrefix()).toBe('DEBUG');
}, `const juris = new Juris();

const ConfigurablePlugin = (props, context) => {
    const { prefix = 'msg', enabled = true } = props;
    
    return {
        api: {
            getMessage: (text) => enabled ? \`\${prefix}: \${text}\` : text,
            isEnabled: () => enabled
        }
    };
};

juris.registerHeadlessComponent('configurable', ConfigurablePlugin);

const instance1 = juris.initializeHeadlessComponent('configurable', {
    prefix: 'LOG',
    enabled: true
});

testFramework.expect(instance1.api.getMessage('hello')).toBe('LOG: hello');
testFramework.expect(instance1.api.isEnabled()).toBeTruthy();`);

/**
 * Test Snippets for Enhance API
 * Following the established test pattern with code snippets
 */

 testFramework.addTest('Basic DOM Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    // Create test element
    const testDiv = document.createElement('div');
    testDiv.className = 'test-element';
    testDiv.textContent = 'Original text';
    document.body.appendChild(testDiv);
    
    // Enhance the element
    juris.enhance('.test-element', {
        text: 'Enhanced text',
        className: 'test-element enhanced',
        onclick: () => {
            juris.setState('clicked', true);
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(testDiv.textContent).toBe('Enhanced text');
    testFramework.expect(testDiv.className).toBe('test-element enhanced');
    
    // Test click event
    testDiv.click();
    testFramework.expect(juris.getState('clicked')).toBeTruthy();
    
    // Cleanup
    document.body.removeChild(testDiv);
}, `const juris = new Juris();

// Create test element
const testDiv = document.createElement('div');
testDiv.className = 'test-element';
document.body.appendChild(testDiv);

// Enhance the element
juris.enhance('.test-element', {
    text: 'Enhanced text',
    className: 'test-element enhanced',
    onclick: () => {
        juris.setState('clicked', true);
    }
});

testFramework.expect(testDiv.textContent).toBe('Enhanced text');
testFramework.expect(testDiv.className).toBe('test-element enhanced');

testDiv.click();
testFramework.expect(juris.getState('clicked')).toBeTruthy();`);

testFramework.addTest('Reactive Enhancement Properties', 'Enhance API', async function() {
    const juris = new Juris();
    
    const counterDiv = document.createElement('div');
    counterDiv.className = 'counter';
    document.body.appendChild(counterDiv);
    
    juris.setState('count', 0);
    
    juris.enhance('.counter', (context) => ({
        text: () => `Count: ${context.getState('count', 0)}`,
        className: () => {
            const count = context.getState('count', 0);
            return `counter ${count > 5 ? 'high' : 'low'}`;
        },
        onclick: () => {
            const current = context.getState('count', 0);
            context.setState('count', current + 1);
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 0');
    testFramework.expect(counterDiv.className).toBe('counter low');
    
    // Click to increment
    counterDiv.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 1');
    
    // Set high value
    juris.setState('count', 6);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 6');
    testFramework.expect(counterDiv.className).toBe('counter high');
    
    document.body.removeChild(counterDiv);
}, `const juris = new Juris();
    
    const counterDiv = document.createElement('div');
    counterDiv.className = 'counter';
    document.body.appendChild(counterDiv);
    
    juris.setState('count', 0);
    
    juris.enhance('.counter', (context) => ({
        text: () => \`Count: \${context.getState('count', 0)}\`,
        className: () => {
            const count = context.getState('count', 0);
            return \`counter \${count > 5 ? 'high' : 'low'}\`;
        },
        onclick: () => {
            const current = context.getState('count', 0);
            context.setState('count', current + 1);
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 0');
    testFramework.expect(counterDiv.className).toBe('counter low');
    
    // Click to increment
    counterDiv.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 1');
    
    // Set high value
    juris.setState('count', 6);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 6');
    testFramework.expect(counterDiv.className).toBe('counter high');
    
    document.body.removeChild(counterDiv);`);

testFramework.addTest('Selectors Category Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    const container = document.createElement('div');
    container.className = 'task-list';
    container.innerHTML = `
        <div class="task-item" data-task-id="1">Task 1</div>
        <div class="task-item" data-task-id="2">Task 2</div>
        <button class="add-btn">Add Task</button>
    `;
    document.body.appendChild(container);
    
    juris.setState('tasks', { 1: { completed: false }, 2: { completed: false } });
    
    juris.enhance('.task-list', {
        className: 'task-list enhanced',
        selectors: {
            '.task-item': (context) => {
                const taskId = context.element.dataset.taskId;
                return {
                    className: () => {
                        const completed = context.getState(`tasks.${taskId}.completed`, false);
                        console.log('task-item className', completed);
                        return `task-item ${completed ? 'completed' : 'pending'}`;
                    },
                    onclick: async () => {
                        console.log('task-item onclick', taskId);
                        const current = context.getState(`tasks.${taskId}.completed`, false);
                        context.setState(`tasks.${taskId}.completed`, !current);
                    }
                };
            },
            '.add-btn': (context) => ({
                onclick: () => {
                    context.setState('tasks.3', { completed: false });
                }
            })
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    let taskItem1 = container.querySelector('[data-task-id="1"]');
    testFramework.expect(taskItem1.className).toBe('task-item pending');
    testFramework.expect(container.className).toBe('task-list enhanced');
    
    // Click task to toggle completion
    taskItem1.click();
    await new Promise(resolve => setTimeout(resolve, 20));
    taskItem1 = document.querySelector('[data-task-id="1"]');
    console.log('taskItem1.className', taskItem1.className);
    //testFramework.expect(taskItem1.className).toBe('task-item completed');
    //await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(juris.getState('tasks.1.completed')).toBeTruthy();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(taskItem1.className).toBe('task-item completed');
    
    //document.body.removeChild(container);
}, `const juris = new Juris();

const container = document.createElement('div');
container.className = 'task-list';
container.innerHTML = \`
    <div class="task-item" data-task-id="1">Task 1</div>
    <div class="task-item" data-task-id="2">Task 2</div>
    <button class="add-btn">Add Task</button>
\`;
document.body.appendChild(container);

juris.setState('tasks', { 1: { completed: false }, 2: { completed: false } });

juris.enhance('.task-list', {
    className: 'task-list enhanced',
    selectors: {
        '.task-item': (context) => {
            const taskId = context.element.dataset.taskId;
            return {
                className: () => {
                    const completed = context.getState(\`tasks.\${taskId}.completed\`, false);
                    return \`task-item \${completed ? 'completed' : 'pending'}\`;
                },
                onclick: () => {
                    const current = context.getState(\`tasks.\${taskId}.completed\`, false);
                    context.setState(\`tasks.\${taskId}.completed\`, !current);
                }
            };
        }
    }
});

const taskItem1 = container.querySelector('[data-task-id="1"]');
testFramework.expect(taskItem1.className).toBe('task-item pending');

taskItem1.click();
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(taskItem1.className).toBe('task-item completed');`);

testFramework.addTest('Dynamic Children Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    const listContainer = document.createElement('div');
    listContainer.className = 'dynamic-list';
    document.body.appendChild(listContainer);
    
    juris.setState('items', ['apple', 'banana']);
    
    juris.enhance('.dynamic-list', (context) => ({
        children: () => {
            const items = context.getState('items', []);
            return items.map(item => ({
                div: {
                    key: item,
                    className: 'list-item',
                    text: item,
                    onclick: () => {
                        context.setState('selectedItem', item);
                    }
                }
            }));
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(listContainer.children.length).toBe(2);
    testFramework.expect(listContainer.children[0].textContent).toBe('apple');
    testFramework.expect(listContainer.children[1].textContent).toBe('banana');
    
    // Add new item
    juris.setState('items', ['apple', 'banana', 'cherry']);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(listContainer.children.length).toBe(3);
    testFramework.expect(listContainer.children[2].textContent).toBe('cherry');
    
    // Test click event
    listContainer.children[0].click();
    testFramework.expect(juris.getState('selectedItem')).toBe('apple');
    
    document.body.removeChild(listContainer);
}, `const juris = new Juris();

const listContainer = document.createElement('div');
listContainer.className = 'dynamic-list';
document.body.appendChild(listContainer);

juris.setState('items', ['apple', 'banana']);

juris.enhance('.dynamic-list', (context) => ({
    children: () => {
        const items = context.getState('items', []);
        return items.map(item => ({
            div: {
                key: item,
                className: 'list-item',
                text: item,
                onclick: () => {
                    context.setState('selectedItem', item);
                }
            }
        }));
    }
}));

testFramework.expect(listContainer.children.length).toBe(2);
testFramework.expect(listContainer.children[0].textContent).toBe('apple');

// Add new item
juris.setState('items', ['apple', 'banana', 'cherry']);
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(listContainer.children.length).toBe(3);`);

testFramework.addTest('Style and Attribute Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    const styledDiv = document.createElement('div');
    styledDiv.className = 'styled-element';
    document.body.appendChild(styledDiv);
    
    juris.setState('theme', 'light');
    juris.setState('loading', false);
    
    juris.enhance('.styled-element', (context) => ({
        style: () => ({
            backgroundColor: context.getState('theme') === 'dark' ? '#333' : '#fff',
            color: context.getState('theme') === 'dark' ? '#fff' : '#333',
            opacity: context.getState('loading') ? '0.5' : '1'
        }),
        disabled: () => context.getState('loading', false),
        'data-theme': () => context.getState('theme', 'light'),
        'aria-busy': () => context.getState('loading', false).toString()
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(255, 255, 255)');
    testFramework.expect(styledDiv.style.opacity).toBe('1');
    testFramework.expect(styledDiv.getAttribute('data-theme')).toBe('light');
    testFramework.expect(styledDiv.getAttribute('aria-busy')).toBe('false');
    
    // Change theme
    juris.setState('theme', 'dark');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(51, 51, 51)');
    testFramework.expect(styledDiv.getAttribute('data-theme')).toBe('dark');
    
    // Set loading
    juris.setState('loading', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(styledDiv.style.opacity).toBe('0.5');
    testFramework.expect(styledDiv.getAttribute('aria-busy')).toBe('true');
    
    document.body.removeChild(styledDiv);
}, `const juris = new Juris();

const styledDiv = document.createElement('div');
styledDiv.className = 'styled-element';
document.body.appendChild(styledDiv);

juris.setState('theme', 'light');
juris.setState('loading', false);

juris.enhance('.styled-element', (context) => ({
    style: () => ({
        backgroundColor: context.getState('theme') === 'dark' ? '#333' : '#fff',
        color: context.getState('theme') === 'dark' ? '#fff' : '#333',
        opacity: context.getState('loading') ? '0.5' : '1'
    }),
    disabled: () => context.getState('loading', false),
    'data-theme': () => context.getState('theme', 'light')
}));

testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(255, 255, 255)');
testFramework.expect(styledDiv.getAttribute('data-theme')).toBe('light');

juris.setState('theme', 'dark');
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(51, 51, 51)');`);

testFramework.addTest('Enhancement Cleanup', 'Enhance API', async function() {
    const juris = new Juris();
    
    const testElement = document.createElement('div');
    testElement.className = 'cleanup-test';
    testElement.textContent = 'Original';
    document.body.appendChild(testElement);
    
    // Enhance element and store cleanup function
    const unenhance = juris.enhance('.cleanup-test', {
        text: 'Enhanced',
        className: 'cleanup-test enhanced',
        onclick: () => {
            juris.setState('cleanupClicked', true);
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(testElement.textContent).toBe('Enhanced');
    testFramework.expect(testElement.className).toBe('cleanup-test enhanced');
    
    // Test that enhancement works
    testElement.click();
    testFramework.expect(juris.getState('cleanupClicked')).toBeTruthy();
    
    // Clean up enhancement
    unenhance();
    juris.setState('cleanupClicked', false);
    
    // Test that enhancement is removed (element should not respond to clicks)
    testElement.click();
    testFramework.expect(juris.getState('cleanupClicked')).toBeFalsy();
    
    // Note: Text and className remain as they were last set
    testFramework.expect(testElement.textContent).toBe('Enhanced');
    
    document.body.removeChild(testElement);
}, `const juris = new Juris();

const testElement = document.createElement('div');
testElement.className = 'cleanup-test';
document.body.appendChild(testElement);

// Enhance element and store cleanup function
const unenhance = juris.enhance('.cleanup-test', {
    text: 'Enhanced',
    className: 'cleanup-test enhanced',
    onclick: () => {
        juris.setState('cleanupClicked', true);
    }
});

testFramework.expect(testElement.textContent).toBe('Enhanced');
testFramework.expect(testElement.className).toBe('cleanup-test enhanced');

// Test that enhancement works
testElement.click();
testFramework.expect(juris.getState('cleanupClicked')).toBeTruthy();

// Clean up enhancement
unenhance();
juris.setState('cleanupClicked', false);

// Enhancement is removed (no longer responds to clicks)
testElement.click();
testFramework.expect(juris.getState('cleanupClicked')).toBeFalsy();`);

console.log('Enhance API Tests loaded successfully!');

// StateManager Reset API Tests
testFramework.addTest('StateManager Reset API', 'State Management', async function() {
    const juris = new Juris({
        states: {
            user: { name: 'Default User', authenticated: false },
            app: { theme: 'light', language: 'en' },
            counter: { value: 0 }
        }
    });
    
    // Test initial state
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.authenticated')).toBe(false);
    testFramework.expect(juris.getState('app.theme')).toBe('light');
    testFramework.expect(juris.getState('counter.value')).toBe(0);
    
    // Modify state
    juris.setState('user.name', 'John Doe');
    juris.setState('user.authenticated', true);
    juris.setState('app.theme', 'dark');
    juris.setState('counter.value', 42);
    
    // Verify state changed
    testFramework.expect(juris.getState('user.name')).toBe('John Doe');
    testFramework.expect(juris.getState('user.authenticated')).toBe(true);
    testFramework.expect(juris.getState('app.theme')).toBe('dark');
    testFramework.expect(juris.getState('counter.value')).toBe(42);
    
    // Test complete reset
    juris.stateManager.reset();
    
    // Verify state restored to defaults
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.authenticated')).toBe(false);
    testFramework.expect(juris.getState('app.theme')).toBe('light');
    testFramework.expect(juris.getState('counter.value')).toBe(0);
    
}, `const juris = new Juris({
    states: {
        user: { name: 'Default User', authenticated: false },
        app: { theme: 'light', language: 'en' },
        counter: { value: 0 }
    }
});

// Modify state
juris.setState('user.name', 'John Doe');
juris.setState('user.authenticated', true);
juris.setState('app.theme', 'dark');
juris.setState('counter.value', 42);

// Reset to defaults
juris.stateManager.reset();

// Verify reset worked
testFramework.expect(juris.getState('user.name')).toBe('Default User');
testFramework.expect(juris.getState('user.authenticated')).toBe(false);
testFramework.expect(juris.getState('app.theme')).toBe('light');
testFramework.expect(juris.getState('counter.value')).toBe(0);`);

testFramework.addTest('StateManager Reset with Preserve', 'State Management', async function() {
    const juris = new Juris({
        states: {
            user: { name: 'Default User', authenticated: false },
            app: { theme: 'light', language: 'en' },
            session: { id: null, active: false }
        }
    });
    
    // Modify all state
    juris.setState('user.name', 'Alice');
    juris.setState('user.authenticated', true);
    juris.setState('app.theme', 'dark');
    juris.setState('app.language', 'fr');
    juris.setState('session.id', 'sess_123');
    juris.setState('session.active', true);
    
    // Reset with preserved paths
    juris.stateManager.reset(['app.theme', 'session.id']);
    
    // Verify defaults restored except preserved paths
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.authenticated')).toBe(false);
    testFramework.expect(juris.getState('app.language')).toBe('en');
    testFramework.expect(juris.getState('session.active')).toBe(false);
    
    // Verify preserved paths kept their values
    testFramework.expect(juris.getState('app.theme')).toBe('dark');
    testFramework.expect(juris.getState('session.id')).toBe('sess_123');
    
}, `const juris = new Juris({
    states: {
        user: { name: 'Default User', authenticated: false },
        app: { theme: 'light', language: 'en' },
        session: { id: null, active: false }
    }
});

// Modify state
juris.setState('user.name', 'Alice');
juris.setState('app.theme', 'dark');
juris.setState('session.id', 'sess_123');

// Reset with preservation
juris.stateManager.reset(['app.theme', 'session.id']);

// Verify: defaults restored except preserved paths
testFramework.expect(juris.getState('user.name')).toBe('Default User');
testFramework.expect(juris.getState('app.theme')).toBe('dark'); // preserved
testFramework.expect(juris.getState('session.id')).toBe('sess_123'); // preserved`);

testFramework.addTest('StateManager Reset Empty State', 'State Management', async function() {
    const juris = new Juris(); // No initial states
    
    // Add some state
    juris.setState('dynamic.data', 'test');
    juris.setState('temp.value', 42);
    
    // Verify state exists
    testFramework.expect(juris.getState('dynamic.data')).toBe('test');
    testFramework.expect(juris.getState('temp.value')).toBe(42);
    
    // Reset should clear everything (no defaults to restore)
    juris.stateManager.reset();
    
    // Verify state cleared
    testFramework.expect(juris.getState('dynamic.data')).toBe(null);
    testFramework.expect(juris.getState('temp.value')).toBe(null);
    
}, `const juris = new Juris(); // No initial states

// Add dynamic state
juris.setState('dynamic.data', 'test');
juris.setState('temp.value', 42);

// Reset clears everything
juris.stateManager.reset();

// Verify cleared
testFramework.expect(juris.getState('dynamic.data')).toBe(null);
testFramework.expect(juris.getState('temp.value')).toBe(null);`);


// StateManager Reset API - Component Reactive Tests (Corrected)
testFramework.addTest('Reset with Component Reactivity', 'State Management', async function() {
    let componentCallCount = 0;
    let reactiveCallCount = 0;
    let lastReactiveValue = null;
    
    const TestComponent = (props, context) => {
        componentCallCount++;
        
        return {
            div: {
                text: () => {
                    reactiveCallCount++;
                    const userName = context.getState('user.name', 'Unknown');
                    lastReactiveValue = userName;
                    return `Hello ${userName}`;
                }
            }
        };
    };
    
    const juris = new Juris({
        states: {
            user: { name: 'Default User', role: 'guest' },
            app: { initialized: true }
        },
        layout: { TestComponent: {} } // Use layout to render component once
    });
    
    juris.registerComponent('TestComponent', TestComponent);
    
    // Render the layout (creates components once)
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(componentCallCount).toBe(1); // Component function called once
    testFramework.expect(reactiveCallCount).toBe(1); // Reactive function called once
    testFramework.expect(lastReactiveValue).toBe('Default User');
    
    // Change state - should trigger only reactive function update
    juris.setState('user.name', 'John Doe');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentCallCount).toBe(1); // Component function NOT called again
    testFramework.expect(reactiveCallCount).toBe(2); // Reactive function called again
    testFramework.expect(lastReactiveValue).toBe('John Doe');
    
    // Reset state - should trigger only reactive function update
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentCallCount).toBe(1); // Component function still NOT called again
    testFramework.expect(reactiveCallCount).toBe(3); // Reactive function called again
    testFramework.expect(lastReactiveValue).toBe('Default User');
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.role')).toBe('guest');
    
}, `let componentCallCount = 0;
let reactiveCallCount = 0;
let lastReactiveValue = null;

const TestComponent = (props, context) => {
    componentCallCount++;
    
    return {
        div: {
            text: () => {
                reactiveCallCount++;
                const userName = context.getState('user.name', 'Unknown');
                lastReactiveValue = userName;
                return \`Hello \${userName}\`;
            }
        }
    };
};

const juris = new Juris({
    states: {
        user: { name: 'Default User', role: 'guest' },
        app: { initialized: true }
    },
    layout: { TestComponent: {} }
});

juris.registerComponent('TestComponent', TestComponent);

// Render the layout (creates components once)
juris.render(document.createElement('div'));
await new Promise(resolve => setTimeout(resolve, 10));

// Verify initial state
testFramework.expect(componentCallCount).toBe(1);
testFramework.expect(reactiveCallCount).toBe(1);
testFramework.expect(lastReactiveValue).toBe('Default User');

// Change state - should trigger only reactive function update
juris.setState('user.name', 'John Doe');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(componentCallCount).toBe(1);
testFramework.expect(reactiveCallCount).toBe(2);
testFramework.expect(lastReactiveValue).toBe('John Doe');

// Reset state - should trigger only reactive function update
juris.stateManager.reset();
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(componentCallCount).toBe(1);
testFramework.expect(reactiveCallCount).toBe(3);
testFramework.expect(lastReactiveValue).toBe('Default User');
testFramework.expect(juris.getState('user.name')).toBe('Default User');
testFramework.expect(juris.getState('user.role')).toBe('guest');`);

testFramework.addTest('Reset Branch-Aware with Nested State', 'State Management', async function() {
    const juris = new Juris({
        states: {
            user: {
                profile: { name: 'Default', email: 'default@test.com' },
                settings: { theme: 'light', notifications: true },
                session: { token: null, expiry: null }
            },
            app: {
                ui: { sidebar: false, modal: null },
                data: { cache: {}, loading: false }
            }
        }
    });
    
    // Modify nested state
    juris.setState('user.profile.name', 'Alice');
    juris.setState('user.profile.email', 'alice@test.com');
    juris.setState('user.settings.theme', 'dark');
    juris.setState('user.session.token', 'abc123');
    juris.setState('app.ui.sidebar', true);
    juris.setState('app.data.loading', true);
    
    // Test branch-aware reset with nested preservation
    juris.stateManager.reset(['user.settings', 'app.ui.sidebar']);
    
    // Verify user.profile reset to defaults
    testFramework.expect(juris.getState('user.profile.name')).toBe('Default');
    testFramework.expect(juris.getState('user.profile.email')).toBe('default@test.com');
    
    // Verify user.session reset to defaults
    testFramework.expect(juris.getState('user.session.token')).toBe(null);
    testFramework.expect(juris.getState('user.session.expiry')).toBe(null);
    
    // Verify user.settings preserved (entire branch)
    testFramework.expect(juris.getState('user.settings.theme')).toBe('dark');
    testFramework.expect(juris.getState('user.settings.notifications')).toBe(true);
    
    // Verify app.ui.sidebar preserved (specific path)
    testFramework.expect(juris.getState('app.ui.sidebar')).toBe(true);
    
    // Verify app.ui.modal reset to default
    testFramework.expect(juris.getState('app.ui.modal')).toBe(null);
    
    // Verify app.data reset to defaults
    testFramework.expect(juris.getState('app.data.loading')).toBe(false);
    
}, `const juris = new Juris({
    states: {
        user: {
            profile: { name: 'Default', email: 'default@test.com' },
            settings: { theme: 'light', notifications: true }
        },
        app: { ui: { sidebar: false, modal: null } }
    }
});

// Modify nested state
juris.setState('user.profile.name', 'Alice');
juris.setState('user.settings.theme', 'dark');
juris.setState('app.ui.sidebar', true);

// Branch-aware reset with preservation
juris.stateManager.reset(['user.settings', 'app.ui.sidebar']);

// Profile resets, settings preserved
testFramework.expect(juris.getState('user.profile.name')).toBe('Default');
testFramework.expect(juris.getState('user.settings.theme')).toBe('dark');`);

testFramework.addTest('Reset with Multiple Component Subscriptions', 'State Management', async function() {
    let userComponentRenders = 0;
    let appComponentRenders = 0;
    let sharedComponentRenders = 0;
    
    const UserComponent = (props, context) => {
        userComponentRenders++;
        return {
            div: { text: () => context.getState('user.name', 'No user') }
        };
    };
    
    const AppComponent = (props, context) => {
        appComponentRenders++;
        return {
            div: { text: () => context.getState('app.title', 'No title') }
        };
    };
    
    const SharedComponent = (props, context) => {
        sharedComponentRenders++;
        return {
            div: {
                text: () => `${context.getState('user.name', 'No user')} - ${context.getState('app.title', 'No title')}`
            }
        };
    };
    
    const juris = new Juris({
        states: {
            user: { name: 'Default User', status: 'offline' },
            app: { title: 'Default App', version: '1.0.0' }
        },
        layout: {
            div: {
                children: [
                    { UserComponent: {} },
                    { AppComponent: {} },
                    { SharedComponent: {} }
                ]
            }
        }
    });
    
    // Register components
    juris.registerComponent('UserComponent', UserComponent);
    juris.registerComponent('AppComponent', AppComponent);
    juris.registerComponent('SharedComponent', SharedComponent);
    
    // Render layout (creates all components once)
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial renders
    testFramework.expect(userComponentRenders).toBe(1);
    testFramework.expect(appComponentRenders).toBe(1);
    testFramework.expect(sharedComponentRenders).toBe(1);
    
    // Modify user state - should NOT trigger component re-creation, only reactive updates
    juris.setState('user.name', 'Alice');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(userComponentRenders).toBe(1); // No re-creation
    testFramework.expect(appComponentRenders).toBe(1); // No re-creation
    testFramework.expect(sharedComponentRenders).toBe(1); // No re-creation
    
    // Modify app state - should NOT trigger component re-creation, only reactive updates
    juris.setState('app.title', 'My App');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(userComponentRenders).toBe(1); // No re-creation
    testFramework.expect(appComponentRenders).toBe(1); // No re-creation
    testFramework.expect(sharedComponentRenders).toBe(1); // No re-creation
    
    // Reset all - should NOT trigger component re-creation, only reactive updates
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(userComponentRenders).toBe(1); // No re-creation
    testFramework.expect(appComponentRenders).toBe(1); // No re-creation
    testFramework.expect(sharedComponentRenders).toBe(1); // No re-creation
    
    // Verify state is back to defaults
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('app.title')).toBe('Default App');
    
}, `let userComponentRenders = 0;
let appComponentRenders = 0;
let sharedComponentRenders = 0;

const UserComponent = (props, context) => {
    userComponentRenders++;
    return {
        div: { text: () => context.getState('user.name', 'No user') }
    };
};

const AppComponent = (props, context) => {
    appComponentRenders++;
    return {
        div: { text: () => context.getState('app.title', 'No title') }
    };
};

const SharedComponent = (props, context) => {
    sharedComponentRenders++;
    return {
        div: {
            text: () => \`\${context.getState('user.name', 'No user')} - \${context.getState('app.title', 'No title')}\`
        }
    };
};

const juris = new Juris({
    states: {
        user: { name: 'Default User', status: 'offline' },
        app: { title: 'Default App', version: '1.0.0' }
    },
    layout: {
        div: {
            children: [
                { UserComponent: {} },
                { AppComponent: {} },
                { SharedComponent: {} }
            ]
        }
    }
});

juris.registerComponent('UserComponent', UserComponent);
juris.registerComponent('AppComponent', AppComponent);
juris.registerComponent('SharedComponent', SharedComponent);

juris.render(document.createElement('div'));

// Components created once, state changes trigger surgical DOM updates
testFramework.expect(userComponentRenders).toBe(1);
testFramework.expect(appComponentRenders).toBe(1);
testFramework.expect(sharedComponentRenders).toBe(1);

juris.setState('user.name', 'Alice');
// Components still only created once - surgical updates only
testFramework.expect(userComponentRenders).toBe(1);

juris.stateManager.reset();
// Still only created once
testFramework.expect(userComponentRenders).toBe(1);`);

testFramework.addTest('Reset with Headless Component Integration', 'State Management', async function() {
    let serviceInitialized = false;
    let serviceResetCalled = false;
    
    const DataService = (props, context) => ({
        api: {
            loadData: () => {
                context.setState('data.items', ['item1', 'item2']);
                context.setState('data.loading', false);
            },
            clearData: () => {
                context.setState('data.items', []);
                context.setState('data.loading', false);
            },
            onReset: () => {
                serviceResetCalled = true;
            }
        },
        hooks: {
            onRegister: () => {
                serviceInitialized = true;
                context.setState('service.status', 'ready');
            }
        }
    });
    
    const DataComponent = (props, context) => ({
        div: {
            children: () => {
                const items = context.getState('data.items', []);
                const loading = context.getState('data.loading', true);
                
                if (loading) return [{ span: { text: 'Loading...' } }];
                return items.map((item, i) => ({ div: { text: item, key: i } }));
            }
        }
    });
    
    const juris = new Juris({
        states: {
            data: { items: [], loading: true },
            service: { status: 'initializing' },
            user: { preferences: { autoLoad: false } }
        }
    });
    
    // Register headless and UI components
    juris.registerHeadlessComponent('DataService', DataService);
    juris.registerComponent('DataComponent', DataComponent);
    
    const serviceInstance = juris.initializeHeadlessComponent('DataService');
    const componentEl = juris.componentManager.create('DataComponent');
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(serviceInitialized).toBe(true);
    testFramework.expect(juris.getState('service.status')).toBe('ready');
    testFramework.expect(juris.getState('data.loading')).toBe(true);
    
    // Load data through service
    serviceInstance.api.loadData();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('data.items')).toEqual(['item1', 'item2']);
    testFramework.expect(juris.getState('data.loading')).toBe(false);
    
    // Modify user preferences
    juris.setState('user.preferences.autoLoad', true);
    
    // Reset with preservation of user preferences
    juris.stateManager.reset(['user.preferences']);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify reset restored defaults except preserved
    testFramework.expect(juris.getState('data.items')).toEqual([]);
    testFramework.expect(juris.getState('data.loading')).toBe(true);
    testFramework.expect(juris.getState('service.status')).toBe('initializing');
    testFramework.expect(juris.getState('user.preferences.autoLoad')).toBe(true); // preserved
    
}, `const DataService = (props, context) => ({
    api: {
        loadData: () => context.setState('data.items', ['item1', 'item2'])
    },
    hooks: {
        onRegister: () => context.setState('service.status', 'ready')
    }
});

const juris = new Juris({
    states: {
        data: { items: [], loading: true },
        service: { status: 'initializing' }
    }
});

juris.registerHeadlessComponent('DataService', DataService);
const service = juris.initializeHeadlessComponent('DataService');

service.api.loadData();
// Reset restores defaults, headless components react accordingly
juris.stateManager.reset();`);

testFramework.addTest('Reset Branch Specificity and Inheritance', 'State Management', async function() {
    const juris = new Juris({
        states: {
            app: {
                config: {
                    api: { baseUrl: 'https://api.default.com', timeout: 5000 },
                    ui: { theme: 'light', language: 'en' },
                    features: { beta: false, debug: false }
                },
                runtime: {
                    initialized: false,
                    errors: [],
                    performance: { startTime: null }
                }
            }
        }
    });
    
    // Modify various nested levels
    juris.setState('app.config.api.baseUrl', 'https://api.custom.com');
    juris.setState('app.config.api.timeout', 10000);
    juris.setState('app.config.ui.theme', 'dark');
    juris.setState('app.config.features.beta', true);
    juris.setState('app.runtime.initialized', true);
    juris.setState('app.runtime.errors', ['error1']);
    
    // Test branch-specific preservation
    juris.stateManager.reset(['app.config.ui', 'app.runtime.initialized']);
    
    // Verify app.config.api reset to defaults
    testFramework.expect(juris.getState('app.config.api.baseUrl')).toBe('https://api.default.com');
    testFramework.expect(juris.getState('app.config.api.timeout')).toBe(5000);
    
    // Verify app.config.ui preserved (entire branch)
    testFramework.expect(juris.getState('app.config.ui.theme')).toBe('dark');
    testFramework.expect(juris.getState('app.config.ui.language')).toBe('en');
    
    // Verify app.config.features reset to defaults
    testFramework.expect(juris.getState('app.config.features.beta')).toBe(false);
    testFramework.expect(juris.getState('app.config.features.debug')).toBe(false);
    
    // Verify app.runtime.initialized preserved (specific path)
    testFramework.expect(juris.getState('app.runtime.initialized')).toBe(true);
    
    // Verify app.runtime.errors reset to default
    testFramework.expect(juris.getState('app.runtime.errors')).toEqual([]);
    testFramework.expect(juris.getState('app.runtime.performance.startTime')).toBe(null);
    
}, `const juris = new Juris({
    states: {
        app: {
            config: {
                api: { baseUrl: 'https://api.default.com', timeout: 5000 },
                ui: { theme: 'light', language: 'en' }
            },
            runtime: { initialized: false, errors: [] }
        }
    }
});

// Modify nested state at different levels
juris.setState('app.config.api.baseUrl', 'https://api.custom.com');
juris.setState('app.config.ui.theme', 'dark');
juris.setState('app.runtime.initialized', true);

// Branch-specific reset preserves entire ui branch and specific initialized path
juris.stateManager.reset(['app.config.ui', 'app.runtime.initialized']);

// api branch resets, ui branch preserved, initialized preserved
testFramework.expect(juris.getState('app.config.api.baseUrl')).toBe('https://api.default.com');
testFramework.expect(juris.getState('app.config.ui.theme')).toBe('dark');
testFramework.expect(juris.getState('app.runtime.initialized')).toBe(true);`);

testFramework.addTest('Multi-Level Element Subscription Isolation', 'State Management', async function() {
    let componentRenders = 0;
    let parentReactiveCalls = 0;
    let childReactiveCalls = 0;
    
    const TestComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                className: 'parent',
                children: () => {
                    parentReactiveCalls++;
                    const showItems = context.getState('parent.showItems', true);
                    return showItems ? [
                        {
                            span: {
                                text: () => {
                                    childReactiveCalls++;
                                    return `Child 1: ${context.getState('child.value1', 'default1')}`;
                                },
                                className: () => {
                                    childReactiveCalls++;
                                    return context.getState('child.active1', false) ? 'active' : 'inactive';
                                }
                            }
                        },
                        {
                            p: {
                                text: () => {
                                    childReactiveCalls++;
                                    return `Child 2: ${context.getState('child.value2', 'default2')}`;
                                },
                                style: () => {
                                    childReactiveCalls++;
                                    return { color: context.getState('child.color2', 'black') };
                                }
                            }
                        }
                    ] : [];
                }
            }
        };
    };
    
    const juris = new Juris({
        states: {
            parent: { showItems: true },
            child: { 
                value1: 'Default 1', 
                active1: false,
                value2: 'Default 2', 
                color2: 'blue' 
            }
        },
        layout: { TestComponent: {} }
    });
    
    juris.registerComponent('TestComponent', TestComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(parentReactiveCalls).toBe(1); // children() called once
    testFramework.expect(childReactiveCalls).toBe(4); // 4 child reactive attributes
    
    // Test 1: Change child state - should NOT affect parent reactive function
    juris.setState('child.value1', 'Updated Value 1');
    juris.setState('child.active1', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() NOT called again
    testFramework.expect(childReactiveCalls).toBe(6); // +2 calls (text + className for span)
    
    // Test 2: Change more child state - should still NOT affect parent
    juris.setState('child.value2', 'Updated Value 2');
    juris.setState('child.color2', 'red');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() still NOT called
    testFramework.expect(childReactiveCalls).toBe(8); // +2 calls (text + style for p)
    
    // Test 3: Change parent state - should ONLY affect parent reactive function
    juris.setState('parent.showItems', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(2); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(8); // No additional child calls (children hidden)
    
    // Test 4: Show items again - parent reactive called, children re-rendered
    juris.setState('parent.showItems', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(3); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(12); // +4 calls (all child reactives re-executed)
    
    // Test 5: Reset - verify isolation during reset
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('parent.showItems')).toBe(true);
    testFramework.expect(juris.getState('child.value1')).toBe('Default 1');
    testFramework.expect(juris.getState('child.active1')).toBe(false);
    testFramework.expect(juris.getState('child.value2')).toBe('Default 2');
    testFramework.expect(juris.getState('child.color2')).toBe('blue');
    
    // Reset should trigger updates for changed values
    testFramework.expect(parentReactiveCalls).toBe(4); // No change (showItems already true)
    testFramework.expect(childReactiveCalls).toBe(20); // +4 calls (all child values changed)
    
}, `let componentRenders = 0;
    let parentReactiveCalls = 0;
    let childReactiveCalls = 0;
    
    const TestComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                className: 'parent',
                children: () => {
                    parentReactiveCalls++;
                    const showItems = context.getState('parent.showItems', true);
                    return showItems ? [
                        {
                            span: {
                                text: () => {
                                    childReactiveCalls++;
                                    return \`Child 1: \${context.getState('child.value1', 'default1')}\`;
                                },
                                className: () => {
                                    childReactiveCalls++;
                                    return context.getState('child.active1', false) ? 'active' : 'inactive\';
                                }
                            }
                        },
                        {
                            p: {
                                text: () => {
                                    childReactiveCalls++;
                                    return \`Child 2: \${context.getState('child.value2', 'default2')}\`;
                                },
                                style: () => {
                                    childReactiveCalls++;
                                    return { color: context.getState('child.color2', 'black') };
                                }
                            }
                        }
                    ] : [];
                }
            }
        };
    };
    
    const juris = new Juris({
        states: {
            parent: { showItems: true },
            child: { 
                value1: 'Default 1', 
                active1: false,
                value2: 'Default 2', 
                color2: 'blue' 
            }
        },
        layout: { TestComponent: {} }
    });
    
    juris.registerComponent('TestComponent', TestComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(parentReactiveCalls).toBe(1); // children() called once
    testFramework.expect(childReactiveCalls).toBe(4); // 4 child reactive attributes
    
    // Test 1: Change child state - should NOT affect parent reactive function
    juris.setState('child.value1', 'Updated Value 1');
    juris.setState('child.active1', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() NOT called again
    testFramework.expect(childReactiveCalls).toBe(6); // +2 calls (text + className for span)
    
    // Test 2: Change more child state - should still NOT affect parent
    juris.setState('child.value2', 'Updated Value 2');
    juris.setState('child.color2', 'red');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() still NOT called
    testFramework.expect(childReactiveCalls).toBe(8); // +2 calls (text + style for p)
    
    // Test 3: Change parent state - should ONLY affect parent reactive function
    juris.setState('parent.showItems', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(2); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(8); // No additional child calls (children hidden)
    
    // Test 4: Show items again - parent reactive called, children re-rendered
    juris.setState('parent.showItems', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(3); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(12); // +4 calls (all child reactives re-executed)
    
    // Test 5: Reset - verify isolation during reset
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('parent.showItems')).toBe(true);
    testFramework.expect(juris.getState('child.value1')).toBe('Default 1');
    testFramework.expect(juris.getState('child.active1')).toBe(false);
    testFramework.expect(juris.getState('child.value2')).toBe('Default 2');
    testFramework.expect(juris.getState('child.color2')).toBe('blue');
    
    // Reset should trigger updates for changed values
    testFramework.expect(parentReactiveCalls).toBe(4); // No change (showItems already true)
    testFramework.expect(childReactiveCalls).toBe(16);`);

testFramework.addTest('All Reactive Attributes Test', 'State Management', async function() {
    let componentRenders = 0;
    let textReactiveCalls = 0;
    let childrenReactiveCalls = 0;
    let styleReactiveCalls = 0;
    let classNameReactiveCalls = 0;
    let valueReactiveCalls = 0;
    let dataReactiveCalls = 0;
    let ariaReactiveCalls = 0;
    let titleReactiveCalls = 0;
    let disabledReactiveCalls = 0;
    let readonlyReactiveCalls = 0;
    let tabIndexReactiveCalls = 0;
    let placeholderReactiveCalls = 0;
    
    const AllAttributesComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                // Text reactive attribute
                text: () => {
                    textReactiveCalls++;
                    return `Text: ${context.getState('content.text', 'default text')}`;
                },
            
            // Static attributes (should not affect reactive call counts)
            id: 'static-component-id',
            disabled: false,
            readonly: true,
            tabIndex: 0,
            placeholder: 'Static placeholder text',
            'data-static': 'static-value',
            'aria-hidden': false,
            role: 'button',
            type: 'text',
                
                // Children reactive attribute
                children: () => {
                    childrenReactiveCalls++;
                    const showChildren = context.getState('content.showChildren', true);
                    return showChildren ? [
                        {
                            span: {
                                text: `Child: ${context.getState('content.childText', 'child default')}`
                            }
                        },
                        {
                            p: {
                                text: `Paragraph: ${context.getState('content.paragraphText', 'para default')}`
                            }
                        }
                    ] : [];
                },
                
                // Style reactive attribute
                style: () => {
                    styleReactiveCalls++;
                    return {
                        color: context.getState('styles.color', 'black'),
                        fontSize: context.getState('styles.fontSize', '16px'),
                        backgroundColor: context.getState('styles.bgColor', 'white')
                    };
                },
                
                // ClassName reactive attribute
                className: () => {
                    classNameReactiveCalls++;
                    const theme = context.getState('ui.theme', 'light');
                    const active = context.getState('ui.active', false);
                    return `container ${theme} ${active ? 'active' : 'inactive'}`;
                },
                
                // Value reactive attribute (for form elements)
                value: () => {
                    valueReactiveCalls++;
                    return context.getState('form.inputValue', 'default value');
                },
                
                // Data attribute reactive
                'data-id': () => {
                    dataReactiveCalls++;
                    return `item-${context.getState('meta.id', '0')}`;
                },
                
                // Aria attribute reactive
                'aria-label': () => {
                    ariaReactiveCalls++;
                    return `Label: ${context.getState('accessibility.label', 'default label')}`;
                },
                
                // Title attribute reactive
                title: () => {
                    titleReactiveCalls++;
                    return `Tooltip: ${context.getState('meta.tooltip', 'default tooltip')}`;
                },
                
                // Static HTML attributes as reactive functions
                disabled: () => {
                    disabledReactiveCalls++;
                    return context.getState('form.disabled', false);
                },
                
                readonly: () => {
                    readonlyReactiveCalls++;
                    return context.getState('form.readonly', false);
                },
                
                tabIndex: () => {
                    tabIndexReactiveCalls++;
                    return context.getState('ui.tabIndex', 0);
                },
                
                placeholder: () => {
                    placeholderReactiveCalls++;
                    return `Enter ${context.getState('form.fieldType', 'text')}`;
                },
                
                // Mixed: some static, some reactive
                id: 'static-component-id',
                'data-static': 'static-value',
                role: 'textbox'
            }
        };
    };
    
    const juris = new Juris({
        states: {
            content: {
                text: 'Initial Text',
                showChildren: true,
                childText: 'Initial Child',
                paragraphText: 'Initial Paragraph'
            },
            styles: {
                color: 'blue',
                fontSize: '18px',
                bgColor: 'lightgray'
            },
            ui: {
                theme: 'dark',
                active: false
            },
            form: {
                inputValue: 'initial input'
            },
            meta: {
                id: '123',
                tooltip: 'initial tooltip'
            },
            accessibility: {
                label: 'initial label'
            }
        },
        layout: { AllAttributesComponent: {} }
    });
    
    juris.registerComponent('AllAttributesComponent', AllAttributesComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state - all reactive functions called once
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(textReactiveCalls).toBe(1);
    testFramework.expect(childrenReactiveCalls).toBe(1);
    testFramework.expect(styleReactiveCalls).toBe(1);
    testFramework.expect(classNameReactiveCalls).toBe(1);
    testFramework.expect(valueReactiveCalls).toBe(1);
    testFramework.expect(dataReactiveCalls).toBe(1);
    testFramework.expect(ariaReactiveCalls).toBe(1);
    testFramework.expect(titleReactiveCalls).toBe(1);
    testFramework.expect(disabledReactiveCalls).toBe(1);
    testFramework.expect(readonlyReactiveCalls).toBe(1);
    testFramework.expect(tabIndexReactiveCalls).toBe(1);
    testFramework.expect(placeholderReactiveCalls).toBe(1);
    
    // Test 1: Change text content - only text reactive should be called
    juris.setState('content.text', 'Updated Text');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // +1
    testFramework.expect(childrenReactiveCalls).toBe(1); // No change
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    testFramework.expect(disabledReactiveCalls).toBe(1); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(1); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(1); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(1); // No change
    
    // Test 2: Change children visibility - only children reactive should be called
    juris.setState('content.showChildren', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // +1
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 3: Change multiple style properties - only style reactive should be called
    juris.setState('styles.color', 'red');
    juris.setState('styles.fontSize', '20px');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // +2 (one for each setState)
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 4: Change UI state - only className reactive should be called
    juris.setState('ui.theme', 'light');
    juris.setState('ui.active', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // +2 (one for each setState)
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 5: Change form value - only value reactive should be called
    juris.setState('form.inputValue', 'updated input');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // +1
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 6: Change form control attributes - only respective reactives should be called
    juris.setState('form.disabled', true);
    juris.setState('form.readonly', true);
    juris.setState('ui.tabIndex', 1);
    juris.setState('form.fieldType', 'password');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    testFramework.expect(disabledReactiveCalls).toBe(2); // +1 (form.disabled)
    testFramework.expect(readonlyReactiveCalls).toBe(2); // +1 (form.readonly)
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // +1 (ui.tabIndex)
    testFramework.expect(placeholderReactiveCalls).toBe(2); // +1 (form.fieldType)
    
    // Test 7: Change meta attributes - only respective reactives should be called
    juris.setState('meta.id', '456');
    juris.setState('meta.tooltip', 'updated tooltip');
    juris.setState('accessibility.label', 'updated label');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(2); // +1 (meta.id)
    testFramework.expect(ariaReactiveCalls).toBe(2); // +1 (accessibility.label)
    testFramework.expect(titleReactiveCalls).toBe(2); // +1 (meta.tooltip)
    testFramework.expect(disabledReactiveCalls).toBe(2); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(2); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(2); // No change
    
    // Test 7: Change static attributes (should not affect any reactive calls)
    // Note: In real usage, static attributes can't be changed after creation,
    // but this tests that they don't interfere with reactive tracking
    const beforeStaticTest = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls,
        disabled: disabledReactiveCalls,
        readonly: readonlyReactiveCalls,
        tabIndex: tabIndexReactiveCalls,
        placeholder: placeholderReactiveCalls
    };
    
    // Change some unrelated state that static attributes don't depend on
    juris.setState('unrelated.value', 'test');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify static attributes don't cause reactive calls
    testFramework.expect(textReactiveCalls).toBe(beforeStaticTest.text);
    testFramework.expect(childrenReactiveCalls).toBe(beforeStaticTest.children);
    testFramework.expect(styleReactiveCalls).toBe(beforeStaticTest.style);
    testFramework.expect(classNameReactiveCalls).toBe(beforeStaticTest.className);
    testFramework.expect(valueReactiveCalls).toBe(beforeStaticTest.value);
    testFramework.expect(dataReactiveCalls).toBe(beforeStaticTest.data);
    testFramework.expect(ariaReactiveCalls).toBe(beforeStaticTest.aria);
    testFramework.expect(titleReactiveCalls).toBe(beforeStaticTest.title);
    
    // Test 8: Reset - all reactive functions should be called for changed values
    const preResetCounts = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls,
        disabled: disabledReactiveCalls,
        readonly: readonlyReactiveCalls,
        tabIndex: tabIndexReactiveCalls,
        placeholder: placeholderReactiveCalls
    };
    
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('content.text')).toBe('Initial Text');
    testFramework.expect(juris.getState('content.showChildren')).toBe(true);
    testFramework.expect(juris.getState('styles.color')).toBe('blue');
    testFramework.expect(juris.getState('ui.theme')).toBe('dark');
    testFramework.expect(juris.getState('ui.active')).toBe(false);
    testFramework.expect(juris.getState('form.inputValue')).toBe('initial input');
    testFramework.expect(juris.getState('meta.id')).toBe('123');
    testFramework.expect(juris.getState('meta.tooltip')).toBe('initial tooltip');
    testFramework.expect(juris.getState('form.disabled')).toBe(null);
    testFramework.expect(juris.getState('form.readonly')).toBe(null);
    testFramework.expect(juris.getState('ui.tabIndex')).toBe(null);
    testFramework.expect(juris.getState('form.fieldType')).toBe(null);
    
    // All reactive functions should have been called for reset (values changed)
    testFramework.expect(textReactiveCalls).toBeGreaterThan(preResetCounts.text);
    testFramework.expect(childrenReactiveCalls).toBeGreaterThan(preResetCounts.children);
    testFramework.expect(styleReactiveCalls).toBeGreaterThan(preResetCounts.style);
    testFramework.expect(classNameReactiveCalls).toBeGreaterThan(preResetCounts.className);
    testFramework.expect(valueReactiveCalls).toBeGreaterThan(preResetCounts.value);
    testFramework.expect(dataReactiveCalls).toBeGreaterThan(preResetCounts.data);
    testFramework.expect(ariaReactiveCalls).toBeGreaterThan(preResetCounts.aria);
    testFramework.expect(titleReactiveCalls).toBeGreaterThan(preResetCounts.title);
    testFramework.expect(disabledReactiveCalls).toBeGreaterThan(preResetCounts.disabled);
    testFramework.expect(readonlyReactiveCalls).toBeGreaterThan(preResetCounts.readonly);
    testFramework.expect(tabIndexReactiveCalls).toBeGreaterThan(preResetCounts.tabIndex);
    testFramework.expect(placeholderReactiveCalls).toBeGreaterThan(preResetCounts.placeholder);
    
}, ` let componentRenders = 0;
    let textReactiveCalls = 0;
    let childrenReactiveCalls = 0;
    let styleReactiveCalls = 0;
    let classNameReactiveCalls = 0;
    let valueReactiveCalls = 0;
    let dataReactiveCalls = 0;
    let ariaReactiveCalls = 0;
    let titleReactiveCalls = 0;
    let disabledReactiveCalls = 0;
    let readonlyReactiveCalls = 0;
    let tabIndexReactiveCalls = 0;
    let placeholderReactiveCalls = 0;
    
    const AllAttributesComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                // Text reactive attribute
                text: () => {
                    textReactiveCalls++;
                    return \`Text: \${context.getState('content.text', 'default text')}\`;
                },
            
            // Static attributes (should not affect reactive call counts)
            id: 'static-component-id',
            disabled: false,
            readonly: true,
            tabIndex: 0,
            placeholder: 'Static placeholder text',
            'data-static': 'static-value',
            'aria-hidden': false,
            role: 'button',
            type: 'text',
                
                // Children reactive attribute
                children: () => {
                    childrenReactiveCalls++;
                    const showChildren = context.getState('content.showChildren', true);
                    return showChildren ? [
                        {
                            span: {
                                text: \`Child: \${context.getState('content.childText', 'child default')}\`
                            }
                        },
                        {
                            p: {
                                text: \`Paragraph: \${context.getState('content.paragraphText', 'para default')}\`
                            }
                        }
                    ] : [];
                },
                
                // Style reactive attribute
                style: () => {
                    styleReactiveCalls++;
                    return {
                        color: context.getState('styles.color', 'black'),
                        fontSize: context.getState('styles.fontSize', '16px'),
                        backgroundColor: context.getState('styles.bgColor', 'white')
                    };
                },
                
                // ClassName reactive attribute
                className: () => {
                    classNameReactiveCalls++;
                    const theme = context.getState('ui.theme', 'light');
                    const active = context.getState('ui.active', false);
                    return \`container \${theme} \${active ? 'active' : 'inactive'}\`;
                },
                
                // Value reactive attribute (for form elements)
                value: () => {
                    valueReactiveCalls++;
                    return context.getState('form.inputValue', 'default value');
                },
                
                // Data attribute reactive
                'data-id': () => {
                    dataReactiveCalls++;
                    return \`item-\${context.getState('meta.id', '0')}\`;
                },
                
                // Aria attribute reactive
                'aria-label': () => {
                    ariaReactiveCalls++;
                    return \`Label: \${context.getState('accessibility.label', 'default label')}\`;
                },
                
                // Title attribute reactive
                title: () => {
                    titleReactiveCalls++;
                    return \`Tooltip: \${context.getState('meta.tooltip', 'default tooltip')}\`;
                },
                
                // Static HTML attributes as reactive functions
                disabled: () => {
                    disabledReactiveCalls++;
                    return context.getState('form.disabled', false);
                },
                
                readonly: () => {
                    readonlyReactiveCalls++;
                    return context.getState('form.readonly', false);
                },
                
                tabIndex: () => {
                    tabIndexReactiveCalls++;
                    return context.getState('ui.tabIndex', 0);
                },
                
                placeholder: () => {
                    placeholderReactiveCalls++;
                    return \`Enter \${context.getState('form.fieldType', 'text')}\`;
                },
                
                // Mixed: some static, some reactive
                id: 'static-component-id',
                'data-static': 'static-value',
                role: 'textbox'
            }
        };
    };
    
    const juris = new Juris({
        states: {
            content: {
                text: 'Initial Text',
                showChildren: true,
                childText: 'Initial Child',
                paragraphText: 'Initial Paragraph'
            },
            styles: {
                color: 'blue',
                fontSize: '18px',
                bgColor: 'lightgray'
            },
            ui: {
                theme: 'dark',
                active: false
            },
            form: {
                inputValue: 'initial input'
            },
            meta: {
                id: '123',
                tooltip: 'initial tooltip'
            },
            accessibility: {
                label: 'initial label'
            }
        },
        layout: { AllAttributesComponent: {} }
    });
    
    juris.registerComponent('AllAttributesComponent', AllAttributesComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state - all reactive functions called once
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(textReactiveCalls).toBe(1);
    testFramework.expect(childrenReactiveCalls).toBe(1);
    testFramework.expect(styleReactiveCalls).toBe(1);
    testFramework.expect(classNameReactiveCalls).toBe(1);
    testFramework.expect(valueReactiveCalls).toBe(1);
    testFramework.expect(dataReactiveCalls).toBe(1);
    testFramework.expect(ariaReactiveCalls).toBe(1);
    testFramework.expect(titleReactiveCalls).toBe(1);
    testFramework.expect(disabledReactiveCalls).toBe(1);
    testFramework.expect(readonlyReactiveCalls).toBe(1);
    testFramework.expect(tabIndexReactiveCalls).toBe(1);
    testFramework.expect(placeholderReactiveCalls).toBe(1);
    
    // Test 1: Change text content - only text reactive should be called
    juris.setState('content.text', 'Updated Text');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // +1
    testFramework.expect(childrenReactiveCalls).toBe(1); // No change
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    testFramework.expect(disabledReactiveCalls).toBe(1); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(1); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(1); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(1); // No change
    
    // Test 2: Change children visibility - only children reactive should be called
    juris.setState('content.showChildren', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // +1
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 3: Change multiple style properties - only style reactive should be called
    juris.setState('styles.color', 'red');
    juris.setState('styles.fontSize', '20px');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // +2 (one for each setState)
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 4: Change UI state - only className reactive should be called
    juris.setState('ui.theme', 'light');
    juris.setState('ui.active', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // +2 (one for each setState)
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 5: Change form value - only value reactive should be called
    juris.setState('form.inputValue', 'updated input');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // +1
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 6: Change form control attributes - only respective reactives should be called
    juris.setState('form.disabled', true);
    juris.setState('form.readonly', true);
    juris.setState('ui.tabIndex', 1);
    juris.setState('form.fieldType', 'password');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(2); // No change
    testFramework.expect(ariaReactiveCalls).toBe(2); // No change
    testFramework.expect(titleReactiveCalls).toBe(2); // No change
    testFramework.expect(disabledReactiveCalls).toBe(2); // +1 (form.disabled)
    testFramework.expect(readonlyReactiveCalls).toBe(2); // +1 (form.readonly)
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // +1 (ui.tabIndex)
    testFramework.expect(placeholderReactiveCalls).toBe(2); // +1 (form.fieldType)
    
    // Test 7: Change meta attributes - only respective reactives should be called
    juris.setState('meta.id', '456');
    juris.setState('meta.tooltip', 'updated tooltip');
    juris.setState('accessibility.label', 'updated label');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(3); // +1 (meta.id)
    testFramework.expect(ariaReactiveCalls).toBe(3); // +1 (accessibility.label)
    testFramework.expect(titleReactiveCalls).toBe(3); // +1 (meta.tooltip)
    testFramework.expect(disabledReactiveCalls).toBe(2); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(2); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(2); // No change
    
    // Test 7: Change static attributes (should not affect any reactive calls)
    // Note: In real usage, static attributes can't be changed after creation,
    // but this tests that they don't interfere with reactive tracking
    const beforeStaticTest = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls,
        disabled: disabledReactiveCalls,
        readonly: readonlyReactiveCalls,
        tabIndex: tabIndexReactiveCalls,
        placeholder: placeholderReactiveCalls
    };
    
    // Change some unrelated state that static attributes don't depend on
    juris.setState('unrelated.value', 'test');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify static attributes don't cause reactive calls
    testFramework.expect(textReactiveCalls).toBe(beforeStaticTest.text);
    testFramework.expect(childrenReactiveCalls).toBe(beforeStaticTest.children);
    testFramework.expect(styleReactiveCalls).toBe(beforeStaticTest.style);
    testFramework.expect(classNameReactiveCalls).toBe(beforeStaticTest.className);
    testFramework.expect(valueReactiveCalls).toBe(beforeStaticTest.value);
    testFramework.expect(dataReactiveCalls).toBe(beforeStaticTest.data);
    testFramework.expect(ariaReactiveCalls).toBe(beforeStaticTest.aria);
    testFramework.expect(titleReactiveCalls).toBe(beforeStaticTest.title);
    
    // Test 8: Reset - all reactive functions should be called for changed values
    const preResetCounts = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls
    };
    
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('content.text')).toBe('Initial Text');
    testFramework.expect(juris.getState('content.showChildren')).toBe(true);
    testFramework.expect(juris.getState('styles.color')).toBe('blue');
    testFramework.expect(juris.getState('ui.theme')).toBe('dark');
    testFramework.expect(juris.getState('ui.active')).toBe(false);
    testFramework.expect(juris.getState('form.inputValue')).toBe('initial input');
    testFramework.expect(juris.getState('meta.id')).toBe('123');
    testFramework.expect(juris.getState('meta.tooltip')).toBe('initial tooltip');
    testFramework.expect(juris.getState('form.disabled')).toBe(false);
    testFramework.expect(juris.getState('form.readonly')).toBe(false);
    testFramework.expect(juris.getState('ui.tabIndex')).toBe(0);
    testFramework.expect(juris.getState('form.fieldType')).toBe('text');
    
    // All reactive functions should have been called for reset (values changed)
    testFramework.expect(textReactiveCalls).toBeGreaterThan(preResetCounts.text);
    testFramework.expect(childrenReactiveCalls).toBeGreaterThan(preResetCounts.children);
    testFramework.expect(styleReactiveCalls).toBeGreaterThan(preResetCounts.style);
    testFramework.expect(classNameReactiveCalls).toBeGreaterThan(preResetCounts.className);
    testFramework.expect(valueReactiveCalls).toBeGreaterThan(preResetCounts.value);
    testFramework.expect(dataReactiveCalls).toBeGreaterThan(preResetCounts.data);
    testFramework.expect(ariaReactiveCalls).toBeGreaterThan(preResetCounts.aria);
    testFramework.expect(titleReactiveCalls).toBeGreaterThan(preResetCounts.title);
    testFramework.expect(disabledReactiveCalls).toBeGreaterThan(preResetCounts.disabled);
    testFramework.expect(readonlyReactiveCalls).toBeGreaterThan(preResetCounts.readonly);
    testFramework.expect(tabIndexReactiveCalls).toBeGreaterThan(preResetCounts.tabIndex);
    testFramework.expect(placeholderReactiveCalls).toBeGreaterThan(preResetCounts.placeholder);
    `);


}

        // Initialize tests
        defineTests();

        // Component Definitions
        const Header = (props, context) => ({
            header: {
                style: {
                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    color: 'white',
                    padding: '20px',
                    textAlign: 'center'
                },
                children: [
                    {
                        h1: {
                            style: { margin: '0 0 8px 0', fontSize: '24px' },
                            text: ' Juris Test Interface'
                        }
                    },
                    {
                        p: {
                            style: { margin: '0', opacity: '0.9' },
                            text: 'Pure Juris Implementation - Testing the Framework with Itself'
                        }
                    }
                ]
            }
        });

        const TestSummary = (props, context) => ({
            div: {
                style: { 
                    marginLeft: 'auto', 
                    fontSize: '14px', 
                    display: 'flex', 
                    gap: '16px',
                    alignItems: 'center'
                },
                children: () => {
                    const results = context.getState('testResults') || {};
                    const total = Object.keys(results).length;
                    const passed = Object.values(results).filter(r => r.status === 'pass').length;
                    const failed = Object.values(results).filter(r => r.status === 'fail').length;
                    const running = Object.values(results).filter(r => r.status === 'running').length;
                    
                    if (total === 0) {
                        return [{
                            span: {
                                style: { color: '#888' },
                                text: `${testFramework.tests.size} tests available`
                            }
                        }];
                    }
                    
                    return [
                        {
                            span: {
                                style: { color: '#4CAF50', fontWeight: 'bold' },
                                text: ` ${passed}`
                            }
                        },
                        {
                            span: {
                                style: { color: '#f44336', fontWeight: 'bold' },
                                text: ` ${failed}`
                            }
                        },
                        running > 0 ? {
                            span: {
                                style: { color: '#2196F3', fontWeight: 'bold' },
                                text: ` ${running}`
                            }
                        } : null,
                        {
                            span: {
                                style: { color: '#888' },
                                text: `(${total}/${testFramework.tests.size})`
                            }
                        }
                    ];
                }
            }
        });

        const Controls = (props, context) => ({
            div: {
                style: {
                    padding: '16px 20px',
                    background: '#2d2d2d',
                    borderBottom: '1px solid #444',
                    display: 'flex',
                    gap: '12px',
                    alignItems: 'center'
                },
                children: [
                    {
                        button: {
                            style: {
                                background: '#4CAF50',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            },
                            text: () => context.getState('isRunning') ? ' Running...' : ' Run All Tests',
                            onclick: async () => {
                                if (context.getState('isRunning')) return;
                                
                                context.setState('isRunning', true);
                                
                                for (const [testName] of testFramework.tests) {
                                    context.setState(`testResults.${testName}`, { status: 'running' });
                                    const result = await testFramework.runTest(testName);
                                    context.setState(`testResults.${testName}`, result);
                                    await new Promise(resolve => setTimeout(resolve, 100));
                                }
                                
                                context.setState('isRunning', false);
                            }
                        }
                    },
                    {
                        button: {
                            style: {
                                background: '#2196F3',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            },
                            text: 'Run Selected Test',
                            onclick: async () => {
                                const selectedTest = context.getState('selectedTest');
                                if (!selectedTest) return;
                                
                                context.setState(`testResults.${selectedTest}`, { status: 'running' });
                                const result = await testFramework.runTest(selectedTest);
                                context.setState(`testResults.${selectedTest}`, result);
                            }
                        }
                    },
                    {
                        button: {
                            style: {
                                background: '#FF9800',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            },
                            text: 'Clear Results',
                            onclick: () => {
                                context.setState('testResults', {});
                                context.setState('selectedTest', null);
                            }
                        }
                    },
                    { 'TestSummary': {} }
                ]
            }
        });

        const CategoryHeader = (props, context) => ({
            div: {
                style: {
                    padding: '12px 16px',
                    background: '#333',
                    fontWeight: 'bold',
                    borderBottom: '1px solid #444',
                    fontSize: '14px'
                },
                text: props.category
            }
        });

        const TestListItem = (props, context) => {
            const test = props.test;
            
            return {
                div: {
                    style: () => {
                        const isSelected = context.getState('selectedTest') === test.name;
                        const result = context.getState(`testResults.${test.name}`);
                        
                        return {
                            padding: '12px 16px',
                            cursor: 'pointer',
                            borderBottom: '1px solid #333',
                            backgroundColor: isSelected ? '#2d2d2d' : 'transparent',
                            borderLeft: (() => {
                                if (isSelected) return '4px solid #667eea';
                                const status = result?.status;
                                if (status === 'pass') return '4px solid #4CAF50';
                                if (status === 'fail') return '4px solid #f44336';
                                if (status === 'running') return '4px solid #2196F3';
                                return '4px solid #666';
                            })(),
                            transition: 'all 0.2s ease'
                        };
                    },
                    onclick: () => {
                        console.log('Clicking test:', test.name);
                        context.setState('selectedTest', test.name);
                    },
                    children: () => {
                        const isSelected = context.getState('selectedTest') === test.name;
                        const result = context.getState(`testResults.${test.name}`);
                        
                        return [
                            {
                                div: {
                                    style: {
                                        fontWeight: isSelected ? 'bold' : 'normal',
                                        marginBottom: '4px',
                                        color: isSelected ? '#ffffff' : '#ccc',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px'
                                    },
                                    children: [
                                        {
                                            span: {
                                                style: { fontSize: '12px' },
                                                text: (() => {
                                                    if (!result) return '';
                                                    if (result.status === 'pass') return '';
                                                    if (result.status === 'fail') return '';
                                                    if (result.status === 'running') return '';
                                                    return '';
                                                })()
                                            }
                                        },
                                        {
                                            span: { text: test.name }
                                        }
                                    ]
                                }
                            },
                            {
                                div: {
                                    style: {
                                        fontSize: '12px',
                                        color: isSelected ? '#aaa' : '#888'
                                    },
                                    text: test.category
                                }
                            },
                            {
                                div: {
                                    style: {
                                        fontSize: '12px',
                                        marginTop: '4px',
                                        color: isSelected ? '#999' : '#777'
                                    },
                                    text: (() => {
                                        if (!result) return '';
                                        if (result.status === 'running') return 'Running...';
                                        if (result.duration) return `${Math.round(result.duration)}ms`;
                                        if (result.status === 'fail' && result.error) {
                                            return `Error: ${result.error.message.substring(0, 30)}...`;
                                        }
                                        return '';
                                    })()
                                }
                            }
                        ];
                    }
                }
            };
        };

        const TestList = (props, context) => ({
            div: {
                style: {
                    width: '400px',
                    background: '#252525',
                    borderRight: '1px solid #444',
                    overflow: 'auto'
                },
                children: () => {
                    const categories = testFramework.getTestsByCategory();
                    const result = [];
                    
                    Object.entries(categories).forEach(([category, tests]) => {
                        result.push({ 'CategoryHeader': { category } });
                        
                        tests.forEach(test => {
                            result.push({ 'TestListItem': { test } });
                        });
                    });
                    
                    return result;
                }
            }
        });

        const TestCodeViewer = (props, context) => {
            return {
                div: {
                    style: { padding: '20px', height: '100%', overflow: 'auto' },
                    children: () => {
                        const selectedTest = context.getState('selectedTest');
                        const result = context.getState(`testResults.${selectedTest}`);
                        const test = selectedTest ? testFramework.tests.get(selectedTest) : null;
                        
                        if (!test) {
                            return [{
                                div: {
                                    style: { 
                                        padding: '20px', 
                                        textAlign: 'center', 
                                        color: '#666',
                                        fontSize: '16px'
                                    },
                                    text: 'Select a test to view its code and results'
                                }
                            }];
                        }
                        
                        const children = [
                            {
                                h2: {
                                    style: { marginBottom: '16px', color: '#e0e0e0' },
                                    text: test.name
                                }
                            },
                            {
                                div: {
                                    style: { 
                                        marginBottom: '20px',
                                        padding: '12px',
                                        background: '#2d2d2d',
                                        borderRadius: '4px'
                                    },
                                    children: [
                                        {
                                            strong: { text: 'Category: ' }
                                        },
                                        {
                                            span: {
                                                style: { color: '#9cdcfe' },
                                                text: test.category
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                h3: {
                                    style: { marginBottom: '12px', color: '#dcdcaa' },
                                    text: 'Test Code:'
                                }
                            },
                            {
                                pre: {
                                    style: {
                                        background: '#1a1a1a',
                                        padding: '16px',
                                        borderRadius: '4px',
                                        overflow: 'auto',
                                        fontSize: '14px',
                                        lineHeight: '1.5',
                                        border: '1px solid #333',
                                        whiteSpace: 'pre-wrap'
                                    },
                                    innerHTML: highlightCode(test.code)
                                }
                            }
                        ];

                        if (result) {
                            children.splice(2, 0, {
                                div: {
                                    style: { 
                                        marginBottom: '16px',
                                        padding: '12px',
                                        borderRadius: '4px',
                                        backgroundColor: (() => {
                                            if (result.status === 'pass') return 'rgba(76, 175, 80, 0.1)';
                                            if (result.status === 'fail') return 'rgba(244, 67, 54, 0.1)';
                                            if (result.status === 'running') return 'rgba(33, 150, 243, 0.1)';
                                            return '#2d2d2d';
                                        })(),
                                        border: (() => {
                                            if (result.status === 'pass') return '1px solid #4CAF50';
                                            if (result.status === 'fail') return '1px solid #f44336';
                                            if (result.status === 'running') return '1px solid #2196F3';
                                            return '1px solid #666';
                                        })()
                                    },
                                    children: [
                                        {
                                            div: {
                                                style: { 
                                                    display: 'flex', 
                                                    alignItems: 'center', 
                                                    gap: '8px', 
                                                    marginBottom: '8px' 
                                                },
                                                children: [
                                                    {
                                                        span: {
                                                            style: { fontSize: '16px' },
                                                            text: (() => {
                                                                if (result.status === 'pass') return '';
                                                                if (result.status === 'fail') return '';
                                                                if (result.status === 'running') return '';
                                                                return '';
                                                            })()
                                                        }
                                                    },
                                                    {
                                                        strong: { 
                                                            text: result.status.toUpperCase(),
                                                            style: {
                                                                color: (() => {
                                                                    if (result.status === 'pass') return '#4CAF50';
                                                                    if (result.status === 'fail') return '#f44336';
                                                                    if (result.status === 'running') return '#2196F3';
                                                                    return '#888';
                                                                })()
                                                            }
                                                        }
                                                    },
                                                    result.duration ? {
                                                        span: {
                                                            style: { marginLeft: '10px', color: '#888', fontSize: '12px' },
                                                            text: `(${Math.round(result.duration)}ms)`
                                                        }
                                                    } : null
                                                ]
                                            }
                                        },
                                        result.assertions && result.assertions.length > 0 ? {
                                            div: {
                                                style: { fontSize: '12px', color: '#ccc' },
                                                text: `${result.assertions.filter(a => a.passed).length}/${result.assertions.length} assertions passed`
                                            }
                                        } : null
                                    ]
                                }
                            });

                            // Add assertions if available
                            if (result.assertions && result.assertions.length > 0) {
                                children.push({
                                    div: {
                                        style: { marginTop: '20px' },
                                        children: [
                                            {
                                                h3: {
                                                    style: { marginBottom: '12px', color: '#dcdcaa' },
                                                    text: `Assertions (${result.assertions.filter(a => a.passed).length}/${result.assertions.length}):`
                                                }
                                            },
                                            ...result.assertions.map(assertion => ({
                                                div: {
                                                    className: `assertion ${assertion.passed ? 'pass' : 'fail'}`,
                                                    style: {
                                                        margin: '4px 0',
                                                        padding: '6px 10px',
                                                        borderRadius: '3px',
                                                        fontSize: '13px',
                                                        backgroundColor: assertion.passed ? 'rgba(76, 175, 80, 0.1)' : 'rgba(244, 67, 54, 0.1)',
                                                        color: assertion.passed ? '#4CAF50' : '#f44336',
                                                        border: assertion.passed ? '1px solid rgba(76, 175, 80, 0.3)' : '1px solid rgba(244, 67, 54, 0.3)'
                                                    },
                                                    text: `${assertion.passed ? '' : ''} ${assertion.message}`
                                                }
                                            }))
                                        ]
                                    }
                                });
                            }

                            // Add error if available
                            if (result.error) {
                                children.push({
                                    div: {
                                        style: { marginTop: '20px' },
                                        children: [
                                            {
                                                h3: {
                                                    style: { marginBottom: '12px', color: '#f44336' },
                                                    text: 'Error Details:'
                                                }
                                            },
                                            {
                                                div: {
                                                    className: 'error-stack',
                                                    style: {
                                                        backgroundColor: '#2a1a1a',
                                                        padding: '12px',
                                                        margin: '5px 0',
                                                        borderRadius: '4px',
                                                        fontSize: '12px',
                                                        whiteSpace: 'pre-wrap',
                                                        overflowX: 'auto',
                                                        border: '1px solid #f44336'
                                                    },
                                                    text: result.error.stack || result.error.message
                                                }
                                            }
                                        ]
                                    }
                                });
                            }
                        }
                        
                        return children;
                    }
                }
            };
        };

        const MainContent = (props, context) => ({
            div: {
                style: {
                    flex: '1',
                    display: 'flex',
                    overflow: 'hidden'
                },
                children: [
                    { 'TestList': {} },
                    {
                        div: {
                            style: {
                                flex: '1',
                                background: '#1e1e1e',
                                overflow: 'hidden'
                            },
                            children: [
                                { 'TestCodeViewer': {} }
                            ]
                        }
                    }
                ]
            }
        });

        const App = (props, context) => ({
            div: {
                style: {
                    height: '100vh',
                    display: 'flex',
                    flexDirection: 'column',
                    background: '#1a1a1a'
                },
                children: [
                    { 'Header': {} },
                    { 'Controls': {} },
                    { 'MainContent': {} }
                ]
            }
        });

        // Juris Application Configuration
        const jurisApp = new Juris({
            renderMode: 'fine-grained',
            states: {
                selectedTest: null,
                testResults: {},
                isRunning: false,
                filter: ''
            },
            components: {
                Header,
                Controls,
                TestSummary,
                CategoryHeader,
                TestListItem,
                TestList,
                TestCodeViewer,
                MainContent,
                App
            },
            layout: { 'App': {} }
        });

        // Render the application
        jurisApp.render('#app');
    </script>
</body>
</html>